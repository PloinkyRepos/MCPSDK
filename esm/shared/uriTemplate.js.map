{"version":3,"file":"uriTemplate.js","sources":["../../../src/shared/uriTemplate.ts"],"sourcesContent":["// Claude-authored implementation of RFC 6570 URI Templates\n\nexport type Variables = Record<string, string | string[]>;\n\nconst MAX_TEMPLATE_LENGTH = 1000000; // 1MB\nconst MAX_VARIABLE_LENGTH = 1000000; // 1MB\nconst MAX_TEMPLATE_EXPRESSIONS = 10000;\nconst MAX_REGEX_LENGTH = 1000000; // 1MB\n\nexport class UriTemplate {\n    /**\n     * Returns true if the given string contains any URI template expressions.\n     * A template expression is a sequence of characters enclosed in curly braces,\n     * like {foo} or {?bar}.\n     */\n    static isTemplate(str: string): boolean {\n        // Look for any sequence of characters between curly braces\n        // that isn't just whitespace\n        return /\\{[^}\\s]+\\}/.test(str);\n    }\n\n    private static validateLength(str: string, max: number, context: string): void {\n        if (str.length > max) {\n            throw new Error(`${context} exceeds maximum length of ${max} characters (got ${str.length})`);\n        }\n    }\n    private readonly template: string;\n    private readonly parts: Array<string | { name: string; operator: string; names: string[]; exploded: boolean }>;\n\n    get variableNames(): string[] {\n        return this.parts.flatMap(part => (typeof part === 'string' ? [] : part.names));\n    }\n\n    constructor(template: string) {\n        UriTemplate.validateLength(template, MAX_TEMPLATE_LENGTH, 'Template');\n        this.template = template;\n        this.parts = this.parse(template);\n    }\n\n    toString(): string {\n        return this.template;\n    }\n\n    private parse(template: string): Array<string | { name: string; operator: string; names: string[]; exploded: boolean }> {\n        const parts: Array<string | { name: string; operator: string; names: string[]; exploded: boolean }> = [];\n        let currentText = '';\n        let i = 0;\n        let expressionCount = 0;\n\n        while (i < template.length) {\n            if (template[i] === '{') {\n                if (currentText) {\n                    parts.push(currentText);\n                    currentText = '';\n                }\n                const end = template.indexOf('}', i);\n                if (end === -1) throw new Error('Unclosed template expression');\n\n                expressionCount++;\n                if (expressionCount > MAX_TEMPLATE_EXPRESSIONS) {\n                    throw new Error(`Template contains too many expressions (max ${MAX_TEMPLATE_EXPRESSIONS})`);\n                }\n\n                const expr = template.slice(i + 1, end);\n                const operator = this.getOperator(expr);\n                const exploded = expr.includes('*');\n                const names = this.getNames(expr);\n                const name = names[0];\n\n                // Validate variable name length\n                for (const name of names) {\n                    UriTemplate.validateLength(name, MAX_VARIABLE_LENGTH, 'Variable name');\n                }\n\n                parts.push({ name, operator, names, exploded });\n                i = end + 1;\n            } else {\n                currentText += template[i];\n                i++;\n            }\n        }\n\n        if (currentText) {\n            parts.push(currentText);\n        }\n\n        return parts;\n    }\n\n    private getOperator(expr: string): string {\n        const operators = ['+', '#', '.', '/', '?', '&'];\n        return operators.find(op => expr.startsWith(op)) || '';\n    }\n\n    private getNames(expr: string): string[] {\n        const operator = this.getOperator(expr);\n        return expr\n            .slice(operator.length)\n            .split(',')\n            .map(name => name.replace('*', '').trim())\n            .filter(name => name.length > 0);\n    }\n\n    private encodeValue(value: string, operator: string): string {\n        UriTemplate.validateLength(value, MAX_VARIABLE_LENGTH, 'Variable value');\n        if (operator === '+' || operator === '#') {\n            return encodeURI(value);\n        }\n        return encodeURIComponent(value);\n    }\n\n    private expandPart(\n        part: {\n            name: string;\n            operator: string;\n            names: string[];\n            exploded: boolean;\n        },\n        variables: Variables\n    ): string {\n        if (part.operator === '?' || part.operator === '&') {\n            const pairs = part.names\n                .map(name => {\n                    const value = variables[name];\n                    if (value === undefined) return '';\n                    const encoded = Array.isArray(value)\n                        ? value.map(v => this.encodeValue(v, part.operator)).join(',')\n                        : this.encodeValue(value.toString(), part.operator);\n                    return `${name}=${encoded}`;\n                })\n                .filter(pair => pair.length > 0);\n\n            if (pairs.length === 0) return '';\n            const separator = part.operator === '?' ? '?' : '&';\n            return separator + pairs.join('&');\n        }\n\n        if (part.names.length > 1) {\n            const values = part.names.map(name => variables[name]).filter(v => v !== undefined);\n            if (values.length === 0) return '';\n            return values.map(v => (Array.isArray(v) ? v[0] : v)).join(',');\n        }\n\n        const value = variables[part.name];\n        if (value === undefined) return '';\n\n        const values = Array.isArray(value) ? value : [value];\n        const encoded = values.map(v => this.encodeValue(v, part.operator));\n\n        switch (part.operator) {\n            case '':\n                return encoded.join(',');\n            case '+':\n                return encoded.join(',');\n            case '#':\n                return '#' + encoded.join(',');\n            case '.':\n                return '.' + encoded.join('.');\n            case '/':\n                return '/' + encoded.join('/');\n            default:\n                return encoded.join(',');\n        }\n    }\n\n    expand(variables: Variables): string {\n        let result = '';\n        let hasQueryParam = false;\n\n        for (const part of this.parts) {\n            if (typeof part === 'string') {\n                result += part;\n                continue;\n            }\n\n            const expanded = this.expandPart(part, variables);\n            if (!expanded) continue;\n\n            // Convert ? to & if we already have a query parameter\n            if ((part.operator === '?' || part.operator === '&') && hasQueryParam) {\n                result += expanded.replace('?', '&');\n            } else {\n                result += expanded;\n            }\n\n            if (part.operator === '?' || part.operator === '&') {\n                hasQueryParam = true;\n            }\n        }\n\n        return result;\n    }\n\n    private escapeRegExp(str: string): string {\n        return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    }\n\n    private partToRegExp(part: {\n        name: string;\n        operator: string;\n        names: string[];\n        exploded: boolean;\n    }): Array<{ pattern: string; name: string }> {\n        const patterns: Array<{ pattern: string; name: string }> = [];\n\n        // Validate variable name length for matching\n        for (const name of part.names) {\n            UriTemplate.validateLength(name, MAX_VARIABLE_LENGTH, 'Variable name');\n        }\n\n        if (part.operator === '?' || part.operator === '&') {\n            for (let i = 0; i < part.names.length; i++) {\n                const name = part.names[i];\n                const prefix = i === 0 ? '\\\\' + part.operator : '&';\n                patterns.push({\n                    pattern: prefix + this.escapeRegExp(name) + '=([^&]+)',\n                    name\n                });\n            }\n            return patterns;\n        }\n\n        let pattern: string;\n        const name = part.name;\n\n        switch (part.operator) {\n            case '':\n                pattern = part.exploded ? '([^/]+(?:,[^/]+)*)' : '([^/,]+)';\n                break;\n            case '+':\n            case '#':\n                pattern = '(.+)';\n                break;\n            case '.':\n                pattern = '\\\\.([^/,]+)';\n                break;\n            case '/':\n                pattern = '/' + (part.exploded ? '([^/]+(?:,[^/]+)*)' : '([^/,]+)');\n                break;\n            default:\n                pattern = '([^/]+)';\n        }\n\n        patterns.push({ pattern, name });\n        return patterns;\n    }\n\n    match(uri: string): Variables | null {\n        UriTemplate.validateLength(uri, MAX_TEMPLATE_LENGTH, 'URI');\n        let pattern = '^';\n        const names: Array<{ name: string; exploded: boolean }> = [];\n\n        for (const part of this.parts) {\n            if (typeof part === 'string') {\n                pattern += this.escapeRegExp(part);\n            } else {\n                const patterns = this.partToRegExp(part);\n                for (const { pattern: partPattern, name } of patterns) {\n                    pattern += partPattern;\n                    names.push({ name, exploded: part.exploded });\n                }\n            }\n        }\n\n        pattern += '$';\n        UriTemplate.validateLength(pattern, MAX_REGEX_LENGTH, 'Generated regex pattern');\n        const regex = new RegExp(pattern);\n        const match = uri.match(regex);\n\n        if (!match) return null;\n\n        const result: Variables = {};\n        for (let i = 0; i < names.length; i++) {\n            const { name, exploded } = names[i];\n            const value = match[i + 1];\n            const cleanName = name.replace('*', '');\n\n            if (exploded && value.includes(',')) {\n                result[cleanName] = value.split(',');\n            } else {\n                result[cleanName] = value;\n            }\n        }\n\n        return result;\n    }\n}\n"],"names":["name","value","encoded","values"],"mappings":"AAIA,MAAM,sBAAsB;AAC5B,MAAM,sBAAsB;AAC5B,MAAM,2BAA2B;AACjC,MAAM,mBAAmB;AAElB,MAAM,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMrB,OAAO,WAAW,KAAsB;AAGpC,WAAO,cAAc,KAAK,GAAG;AAAA,EACjC;AAAA,EAEA,OAAe,eAAe,KAAa,KAAa,SAAuB;AAC3E,QAAI,IAAI,SAAS,KAAK;AAClB,YAAM,IAAI,MAAM,GAAG,OAAO,8BAA8B,GAAG,oBAAoB,IAAI,MAAM,GAAG;AAAA,IAChG;AAAA,EACJ;AAAA,EAIA,IAAI,gBAA0B;AAC1B,WAAO,KAAK,MAAM,QAAQ,CAAA,SAAS,OAAO,SAAS,WAAW,CAAA,IAAK,KAAK,KAAM;AAAA,EAClF;AAAA,EAEA,YAAY,UAAkB;AAC1B,gBAAY,eAAe,UAAU,qBAAqB,UAAU;AACpE,SAAK,WAAW;AAChB,SAAK,QAAQ,KAAK,MAAM,QAAQ;AAAA,EACpC;AAAA,EAEA,WAAmB;AACf,WAAO,KAAK;AAAA,EAChB;AAAA,EAEQ,MAAM,UAA0G;AACpH,UAAM,QAAgG,CAAA;AACtG,QAAI,cAAc;AAClB,QAAI,IAAI;AACR,QAAI,kBAAkB;AAEtB,WAAO,IAAI,SAAS,QAAQ;AACxB,UAAI,SAAS,CAAC,MAAM,KAAK;AACrB,YAAI,aAAa;AACb,gBAAM,KAAK,WAAW;AACtB,wBAAc;AAAA,QAClB;AACA,cAAM,MAAM,SAAS,QAAQ,KAAK,CAAC;AACnC,YAAI,QAAQ,GAAI,OAAM,IAAI,MAAM,8BAA8B;AAE9D;AACA,YAAI,kBAAkB,0BAA0B;AAC5C,gBAAM,IAAI,MAAM,+CAA+C,wBAAwB,GAAG;AAAA,QAC9F;AAEA,cAAM,OAAO,SAAS,MAAM,IAAI,GAAG,GAAG;AACtC,cAAM,WAAW,KAAK,YAAY,IAAI;AACtC,cAAM,WAAW,KAAK,SAAS,GAAG;AAClC,cAAM,QAAQ,KAAK,SAAS,IAAI;AAChC,cAAM,OAAO,MAAM,CAAC;AAGpB,mBAAWA,SAAQ,OAAO;AACtB,sBAAY,eAAeA,OAAM,qBAAqB,eAAe;AAAA,QACzE;AAEA,cAAM,KAAK,EAAE,MAAM,UAAU,OAAO,UAAU;AAC9C,YAAI,MAAM;AAAA,MACd,OAAO;AACH,uBAAe,SAAS,CAAC;AACzB;AAAA,MACJ;AAAA,IACJ;AAEA,QAAI,aAAa;AACb,YAAM,KAAK,WAAW;AAAA,IAC1B;AAEA,WAAO;AAAA,EACX;AAAA,EAEQ,YAAY,MAAsB;AACtC,UAAM,YAAY,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG;AAC/C,WAAO,UAAU,KAAK,CAAA,OAAM,KAAK,WAAW,EAAE,CAAC,KAAK;AAAA,EACxD;AAAA,EAEQ,SAAS,MAAwB;AACrC,UAAM,WAAW,KAAK,YAAY,IAAI;AACtC,WAAO,KACF,MAAM,SAAS,MAAM,EACrB,MAAM,GAAG,EACT,IAAI,CAAA,SAAQ,KAAK,QAAQ,KAAK,EAAE,EAAE,MAAM,EACxC,OAAO,CAAA,SAAQ,KAAK,SAAS,CAAC;AAAA,EACvC;AAAA,EAEQ,YAAY,OAAe,UAA0B;AACzD,gBAAY,eAAe,OAAO,qBAAqB,gBAAgB;AACvE,QAAI,aAAa,OAAO,aAAa,KAAK;AACtC,aAAO,UAAU,KAAK;AAAA,IAC1B;AACA,WAAO,mBAAmB,KAAK;AAAA,EACnC;AAAA,EAEQ,WACJ,MAMA,WACM;AACN,QAAI,KAAK,aAAa,OAAO,KAAK,aAAa,KAAK;AAChD,YAAM,QAAQ,KAAK,MACd,IAAI,CAAA,SAAQ;AACT,cAAMC,SAAQ,UAAU,IAAI;AAC5B,YAAIA,WAAU,OAAW,QAAO;AAChC,cAAMC,WAAU,MAAM,QAAQD,MAAK,IAC7BA,OAAM,IAAI,CAAA,MAAK,KAAK,YAAY,GAAG,KAAK,QAAQ,CAAC,EAAE,KAAK,GAAG,IAC3D,KAAK,YAAYA,OAAM,YAAY,KAAK,QAAQ;AACtD,eAAO,GAAG,IAAI,IAAIC,QAAO;AAAA,MAC7B,CAAC,EACA,OAAO,CAAA,SAAQ,KAAK,SAAS,CAAC;AAEnC,UAAI,MAAM,WAAW,EAAG,QAAO;AAC/B,YAAM,YAAY,KAAK,aAAa,MAAM,MAAM;AAChD,aAAO,YAAY,MAAM,KAAK,GAAG;AAAA,IACrC;AAEA,QAAI,KAAK,MAAM,SAAS,GAAG;AACvB,YAAMC,UAAS,KAAK,MAAM,IAAI,CAAA,SAAQ,UAAU,IAAI,CAAC,EAAE,OAAO,CAAA,MAAK,MAAM,MAAS;AAClF,UAAIA,QAAO,WAAW,EAAG,QAAO;AAChC,aAAOA,QAAO,IAAI,CAAA,MAAM,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,CAAE,EAAE,KAAK,GAAG;AAAA,IAClE;AAEA,UAAM,QAAQ,UAAU,KAAK,IAAI;AACjC,QAAI,UAAU,OAAW,QAAO;AAEhC,UAAM,SAAS,MAAM,QAAQ,KAAK,IAAI,QAAQ,CAAC,KAAK;AACpD,UAAM,UAAU,OAAO,IAAI,CAAA,MAAK,KAAK,YAAY,GAAG,KAAK,QAAQ,CAAC;AAElE,YAAQ,KAAK,UAAA;AAAA,MACT,KAAK;AACD,eAAO,QAAQ,KAAK,GAAG;AAAA,MAC3B,KAAK;AACD,eAAO,QAAQ,KAAK,GAAG;AAAA,MAC3B,KAAK;AACD,eAAO,MAAM,QAAQ,KAAK,GAAG;AAAA,MACjC,KAAK;AACD,eAAO,MAAM,QAAQ,KAAK,GAAG;AAAA,MACjC,KAAK;AACD,eAAO,MAAM,QAAQ,KAAK,GAAG;AAAA,MACjC;AACI,eAAO,QAAQ,KAAK,GAAG;AAAA,IAAA;AAAA,EAEnC;AAAA,EAEA,OAAO,WAA8B;AACjC,QAAI,SAAS;AACb,QAAI,gBAAgB;AAEpB,eAAW,QAAQ,KAAK,OAAO;AAC3B,UAAI,OAAO,SAAS,UAAU;AAC1B,kBAAU;AACV;AAAA,MACJ;AAEA,YAAM,WAAW,KAAK,WAAW,MAAM,SAAS;AAChD,UAAI,CAAC,SAAU;AAGf,WAAK,KAAK,aAAa,OAAO,KAAK,aAAa,QAAQ,eAAe;AACnE,kBAAU,SAAS,QAAQ,KAAK,GAAG;AAAA,MACvC,OAAO;AACH,kBAAU;AAAA,MACd;AAEA,UAAI,KAAK,aAAa,OAAO,KAAK,aAAa,KAAK;AAChD,wBAAgB;AAAA,MACpB;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EAEQ,aAAa,KAAqB;AACtC,WAAO,IAAI,QAAQ,uBAAuB,MAAM;AAAA,EACpD;AAAA,EAEQ,aAAa,MAKwB;AACzC,UAAM,WAAqD,CAAA;AAG3D,eAAWH,SAAQ,KAAK,OAAO;AAC3B,kBAAY,eAAeA,OAAM,qBAAqB,eAAe;AAAA,IACzE;AAEA,QAAI,KAAK,aAAa,OAAO,KAAK,aAAa,KAAK;AAChD,eAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KAAK;AACxC,cAAMA,QAAO,KAAK,MAAM,CAAC;AACzB,cAAM,SAAS,MAAM,IAAI,OAAO,KAAK,WAAW;AAChD,iBAAS,KAAK;AAAA,UACV,SAAS,SAAS,KAAK,aAAaA,KAAI,IAAI;AAAA,UAC5C,MAAAA;AAAAA,QAAA,CACH;AAAA,MACL;AACA,aAAO;AAAA,IACX;AAEA,QAAI;AACJ,UAAM,OAAO,KAAK;AAElB,YAAQ,KAAK,UAAA;AAAA,MACT,KAAK;AACD,kBAAU,KAAK,WAAW,uBAAuB;AACjD;AAAA,MACJ,KAAK;AAAA,MACL,KAAK;AACD,kBAAU;AACV;AAAA,MACJ,KAAK;AACD,kBAAU;AACV;AAAA,MACJ,KAAK;AACD,kBAAU,OAAO,KAAK,WAAW,uBAAuB;AACxD;AAAA,MACJ;AACI,kBAAU;AAAA,IAAA;AAGlB,aAAS,KAAK,EAAE,SAAS,KAAA,CAAM;AAC/B,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,KAA+B;AACjC,gBAAY,eAAe,KAAK,qBAAqB,KAAK;AAC1D,QAAI,UAAU;AACd,UAAM,QAAoD,CAAA;AAE1D,eAAW,QAAQ,KAAK,OAAO;AAC3B,UAAI,OAAO,SAAS,UAAU;AAC1B,mBAAW,KAAK,aAAa,IAAI;AAAA,MACrC,OAAO;AACH,cAAM,WAAW,KAAK,aAAa,IAAI;AACvC,mBAAW,EAAE,SAAS,aAAa,KAAA,KAAU,UAAU;AACnD,qBAAW;AACX,gBAAM,KAAK,EAAE,MAAM,UAAU,KAAK,UAAU;AAAA,QAChD;AAAA,MACJ;AAAA,IACJ;AAEA,eAAW;AACX,gBAAY,eAAe,SAAS,kBAAkB,yBAAyB;AAC/E,UAAM,QAAQ,IAAI,OAAO,OAAO;AAChC,UAAM,QAAQ,IAAI,MAAM,KAAK;AAE7B,QAAI,CAAC,MAAO,QAAO;AAEnB,UAAM,SAAoB,CAAA;AAC1B,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,YAAM,EAAE,MAAM,aAAa,MAAM,CAAC;AAClC,YAAM,QAAQ,MAAM,IAAI,CAAC;AACzB,YAAM,YAAY,KAAK,QAAQ,KAAK,EAAE;AAEtC,UAAI,YAAY,MAAM,SAAS,GAAG,GAAG;AACjC,eAAO,SAAS,IAAI,MAAM,MAAM,GAAG;AAAA,MACvC,OAAO;AACH,eAAO,SAAS,IAAI;AAAA,MACxB;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AACJ;"}