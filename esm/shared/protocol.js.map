{"version":3,"file":"protocol.js","sources":["../../../src/shared/protocol.ts"],"sourcesContent":["import { ZodLiteral, ZodObject, ZodType, z } from 'zod';\nimport {\n    CancelledNotificationSchema,\n    ClientCapabilities,\n    ErrorCode,\n    isJSONRPCError,\n    isJSONRPCRequest,\n    isJSONRPCResponse,\n    isJSONRPCNotification,\n    JSONRPCError,\n    JSONRPCNotification,\n    JSONRPCRequest,\n    JSONRPCResponse,\n    McpError,\n    Notification,\n    PingRequestSchema,\n    Progress,\n    ProgressNotification,\n    ProgressNotificationSchema,\n    Request,\n    RequestId,\n    Result,\n    ServerCapabilities,\n    RequestMeta,\n    MessageExtraInfo,\n    RequestInfo\n} from '../types.js';\nimport { Transport, TransportSendOptions } from './transport.js';\nimport { AuthInfo } from '../server/auth/types.js';\n\n/**\n * Callback for progress notifications.\n */\nexport type ProgressCallback = (progress: Progress) => void;\n\n/**\n * Additional initialization options.\n */\nexport type ProtocolOptions = {\n    /**\n     * Whether to restrict emitted requests to only those that the remote side has indicated that they can handle, through their advertised capabilities.\n     *\n     * Note that this DOES NOT affect checking of _local_ side capabilities, as it is considered a logic error to mis-specify those.\n     *\n     * Currently this defaults to false, for backwards compatibility with SDK versions that did not advertise capabilities correctly. In future, this will default to true.\n     */\n    enforceStrictCapabilities?: boolean;\n    /**\n     * An array of notification method names that should be automatically debounced.\n     * Any notifications with a method in this list will be coalesced if they\n     * occur in the same tick of the event loop.\n     * e.g., ['notifications/tools/list_changed']\n     */\n    debouncedNotificationMethods?: string[];\n};\n\n/**\n * The default request timeout, in miliseconds.\n */\nexport const DEFAULT_REQUEST_TIMEOUT_MSEC = 60000;\n\n/**\n * Options that can be given per request.\n */\nexport type RequestOptions = {\n    /**\n     * If set, requests progress notifications from the remote end (if supported). When progress notifications are received, this callback will be invoked.\n     */\n    onprogress?: ProgressCallback;\n\n    /**\n     * Can be used to cancel an in-flight request. This will cause an AbortError to be raised from request().\n     */\n    signal?: AbortSignal;\n\n    /**\n     * A timeout (in milliseconds) for this request. If exceeded, an McpError with code `RequestTimeout` will be raised from request().\n     *\n     * If not specified, `DEFAULT_REQUEST_TIMEOUT_MSEC` will be used as the timeout.\n     */\n    timeout?: number;\n\n    /**\n     * If true, receiving a progress notification will reset the request timeout.\n     * This is useful for long-running operations that send periodic progress updates.\n     * Default: false\n     */\n    resetTimeoutOnProgress?: boolean;\n\n    /**\n     * Maximum total time (in milliseconds) to wait for a response.\n     * If exceeded, an McpError with code `RequestTimeout` will be raised, regardless of progress notifications.\n     * If not specified, there is no maximum total timeout.\n     */\n    maxTotalTimeout?: number;\n} & TransportSendOptions;\n\n/**\n * Options that can be given per notification.\n */\nexport type NotificationOptions = {\n    /**\n     * May be used to indicate to the transport which incoming request to associate this outgoing notification with.\n     */\n    relatedRequestId?: RequestId;\n};\n\n/**\n * Extra data given to request handlers.\n */\nexport type RequestHandlerExtra<SendRequestT extends Request, SendNotificationT extends Notification> = {\n    /**\n     * An abort signal used to communicate if the request was cancelled from the sender's side.\n     */\n    signal: AbortSignal;\n\n    /**\n     * Information about a validated access token, provided to request handlers.\n     */\n    authInfo?: AuthInfo;\n\n    /**\n     * The session ID from the transport, if available.\n     */\n    sessionId?: string;\n\n    /**\n     * Metadata from the original request.\n     */\n    _meta?: RequestMeta;\n\n    /**\n     * The JSON-RPC ID of the request being handled.\n     * This can be useful for tracking or logging purposes.\n     */\n    requestId: RequestId;\n\n    /**\n     * The original HTTP request.\n     */\n    requestInfo?: RequestInfo;\n\n    /**\n     * Sends a notification that relates to the current request being handled.\n     *\n     * This is used by certain transports to correctly associate related messages.\n     */\n    sendNotification: (notification: SendNotificationT) => Promise<void>;\n\n    /**\n     * Sends a request that relates to the current request being handled.\n     *\n     * This is used by certain transports to correctly associate related messages.\n     */\n    sendRequest: <U extends ZodType<object>>(request: SendRequestT, resultSchema: U, options?: RequestOptions) => Promise<z.infer<U>>;\n};\n\n/**\n * Information about a request's timeout state\n */\ntype TimeoutInfo = {\n    timeoutId: ReturnType<typeof setTimeout>;\n    startTime: number;\n    timeout: number;\n    maxTotalTimeout?: number;\n    resetTimeoutOnProgress: boolean;\n    onTimeout: () => void;\n};\n\n/**\n * Implements MCP protocol framing on top of a pluggable transport, including\n * features like request/response linking, notifications, and progress.\n */\nexport abstract class Protocol<SendRequestT extends Request, SendNotificationT extends Notification, SendResultT extends Result> {\n    private _transport?: Transport;\n    private _requestMessageId = 0;\n    private _requestHandlers: Map<\n        string,\n        (request: JSONRPCRequest, extra: RequestHandlerExtra<SendRequestT, SendNotificationT>) => Promise<SendResultT>\n    > = new Map();\n    private _requestHandlerAbortControllers: Map<RequestId, AbortController> = new Map();\n    private _notificationHandlers: Map<string, (notification: JSONRPCNotification) => Promise<void>> = new Map();\n    private _responseHandlers: Map<number, (response: JSONRPCResponse | Error) => void> = new Map();\n    private _progressHandlers: Map<number, ProgressCallback> = new Map();\n    private _timeoutInfo: Map<number, TimeoutInfo> = new Map();\n    private _pendingDebouncedNotifications = new Set<string>();\n\n    /**\n     * Callback for when the connection is closed for any reason.\n     *\n     * This is invoked when close() is called as well.\n     */\n    onclose?: () => void;\n\n    /**\n     * Callback for when an error occurs.\n     *\n     * Note that errors are not necessarily fatal; they are used for reporting any kind of exceptional condition out of band.\n     */\n    onerror?: (error: Error) => void;\n\n    /**\n     * A handler to invoke for any request types that do not have their own handler installed.\n     */\n    fallbackRequestHandler?: (request: JSONRPCRequest, extra: RequestHandlerExtra<SendRequestT, SendNotificationT>) => Promise<SendResultT>;\n\n    /**\n     * A handler to invoke for any notification types that do not have their own handler installed.\n     */\n    fallbackNotificationHandler?: (notification: Notification) => Promise<void>;\n\n    constructor(private _options?: ProtocolOptions) {\n        this.setNotificationHandler(CancelledNotificationSchema, notification => {\n            const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);\n            controller?.abort(notification.params.reason);\n        });\n\n        this.setNotificationHandler(ProgressNotificationSchema, notification => {\n            this._onprogress(notification as unknown as ProgressNotification);\n        });\n\n        this.setRequestHandler(\n            PingRequestSchema,\n            // Automatic pong by default.\n            _request => ({}) as SendResultT\n        );\n    }\n\n    private _setupTimeout(\n        messageId: number,\n        timeout: number,\n        maxTotalTimeout: number | undefined,\n        onTimeout: () => void,\n        resetTimeoutOnProgress: boolean = false\n    ) {\n        this._timeoutInfo.set(messageId, {\n            timeoutId: setTimeout(onTimeout, timeout),\n            startTime: Date.now(),\n            timeout,\n            maxTotalTimeout,\n            resetTimeoutOnProgress,\n            onTimeout\n        });\n    }\n\n    private _resetTimeout(messageId: number): boolean {\n        const info = this._timeoutInfo.get(messageId);\n        if (!info) return false;\n\n        const totalElapsed = Date.now() - info.startTime;\n        if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {\n            this._timeoutInfo.delete(messageId);\n            throw new McpError(ErrorCode.RequestTimeout, 'Maximum total timeout exceeded', {\n                maxTotalTimeout: info.maxTotalTimeout,\n                totalElapsed\n            });\n        }\n\n        clearTimeout(info.timeoutId);\n        info.timeoutId = setTimeout(info.onTimeout, info.timeout);\n        return true;\n    }\n\n    private _cleanupTimeout(messageId: number) {\n        const info = this._timeoutInfo.get(messageId);\n        if (info) {\n            clearTimeout(info.timeoutId);\n            this._timeoutInfo.delete(messageId);\n        }\n    }\n\n    /**\n     * Attaches to the given transport, starts it, and starts listening for messages.\n     *\n     * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.\n     */\n    async connect(transport: Transport): Promise<void> {\n        this._transport = transport;\n        const _onclose = this.transport?.onclose;\n        this._transport.onclose = () => {\n            _onclose?.();\n            this._onclose();\n        };\n\n        const _onerror = this.transport?.onerror;\n        this._transport.onerror = (error: Error) => {\n            _onerror?.(error);\n            this._onerror(error);\n        };\n\n        const _onmessage = this._transport?.onmessage;\n        this._transport.onmessage = (message, extra) => {\n            _onmessage?.(message, extra);\n            if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n                this._onresponse(message);\n            } else if (isJSONRPCRequest(message)) {\n                this._onrequest(message, extra);\n            } else if (isJSONRPCNotification(message)) {\n                this._onnotification(message);\n            } else {\n                this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));\n            }\n        };\n\n        await this._transport.start();\n    }\n\n    private _onclose(): void {\n        const responseHandlers = this._responseHandlers;\n        this._responseHandlers = new Map();\n        this._progressHandlers.clear();\n        this._pendingDebouncedNotifications.clear();\n        this._transport = undefined;\n        this.onclose?.();\n\n        const error = new McpError(ErrorCode.ConnectionClosed, 'Connection closed');\n        for (const handler of responseHandlers.values()) {\n            handler(error);\n        }\n    }\n\n    private _onerror(error: Error): void {\n        this.onerror?.(error);\n    }\n\n    private _onnotification(notification: JSONRPCNotification): void {\n        const handler = this._notificationHandlers.get(notification.method) ?? this.fallbackNotificationHandler;\n\n        // Ignore notifications not being subscribed to.\n        if (handler === undefined) {\n            return;\n        }\n\n        // Starting with Promise.resolve() puts any synchronous errors into the monad as well.\n        Promise.resolve()\n            .then(() => handler(notification))\n            .catch(error => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));\n    }\n\n    private _onrequest(request: JSONRPCRequest, extra?: MessageExtraInfo): void {\n        const handler = this._requestHandlers.get(request.method) ?? this.fallbackRequestHandler;\n\n        // Capture the current transport at request time to ensure responses go to the correct client\n        const capturedTransport = this._transport;\n\n        if (handler === undefined) {\n            capturedTransport\n                ?.send({\n                    jsonrpc: '2.0',\n                    id: request.id,\n                    error: {\n                        code: ErrorCode.MethodNotFound,\n                        message: 'Method not found'\n                    }\n                })\n                .catch(error => this._onerror(new Error(`Failed to send an error response: ${error}`)));\n            return;\n        }\n\n        const abortController = new AbortController();\n        this._requestHandlerAbortControllers.set(request.id, abortController);\n\n        const fullExtra: RequestHandlerExtra<SendRequestT, SendNotificationT> = {\n            signal: abortController.signal,\n            sessionId: capturedTransport?.sessionId,\n            _meta: request.params?._meta,\n            sendNotification: notification => this.notification(notification, { relatedRequestId: request.id }),\n            sendRequest: (r, resultSchema, options?) => this.request(r, resultSchema, { ...options, relatedRequestId: request.id }),\n            authInfo: extra?.authInfo,\n            requestId: request.id,\n            requestInfo: extra?.requestInfo\n        };\n\n        // Starting with Promise.resolve() puts any synchronous errors into the monad as well.\n        Promise.resolve()\n            .then(() => handler(request, fullExtra))\n            .then(\n                result => {\n                    if (abortController.signal.aborted) {\n                        return;\n                    }\n\n                    return capturedTransport?.send({\n                        result,\n                        jsonrpc: '2.0',\n                        id: request.id\n                    });\n                },\n                error => {\n                    if (abortController.signal.aborted) {\n                        return;\n                    }\n\n                    return capturedTransport?.send({\n                        jsonrpc: '2.0',\n                        id: request.id,\n                        error: {\n                            code: Number.isSafeInteger(error['code']) ? error['code'] : ErrorCode.InternalError,\n                            message: error.message ?? 'Internal error'\n                        }\n                    });\n                }\n            )\n            .catch(error => this._onerror(new Error(`Failed to send response: ${error}`)))\n            .finally(() => {\n                this._requestHandlerAbortControllers.delete(request.id);\n            });\n    }\n\n    private _onprogress(notification: ProgressNotification): void {\n        const { progressToken, ...params } = notification.params;\n        const messageId = Number(progressToken);\n\n        const handler = this._progressHandlers.get(messageId);\n        if (!handler) {\n            this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));\n            return;\n        }\n\n        const responseHandler = this._responseHandlers.get(messageId);\n        const timeoutInfo = this._timeoutInfo.get(messageId);\n\n        if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {\n            try {\n                this._resetTimeout(messageId);\n            } catch (error) {\n                responseHandler(error as Error);\n                return;\n            }\n        }\n\n        handler(params);\n    }\n\n    private _onresponse(response: JSONRPCResponse | JSONRPCError): void {\n        const messageId = Number(response.id);\n        const handler = this._responseHandlers.get(messageId);\n        if (handler === undefined) {\n            this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));\n            return;\n        }\n\n        this._responseHandlers.delete(messageId);\n        this._progressHandlers.delete(messageId);\n        this._cleanupTimeout(messageId);\n\n        if (isJSONRPCResponse(response)) {\n            handler(response);\n        } else {\n            const error = new McpError(response.error.code, response.error.message, response.error.data);\n            handler(error);\n        }\n    }\n\n    get transport(): Transport | undefined {\n        return this._transport;\n    }\n\n    /**\n     * Closes the connection.\n     */\n    async close(): Promise<void> {\n        await this._transport?.close();\n    }\n\n    /**\n     * A method to check if a capability is supported by the remote side, for the given method to be called.\n     *\n     * This should be implemented by subclasses.\n     */\n    protected abstract assertCapabilityForMethod(method: SendRequestT['method']): void;\n\n    /**\n     * A method to check if a notification is supported by the local side, for the given method to be sent.\n     *\n     * This should be implemented by subclasses.\n     */\n    protected abstract assertNotificationCapability(method: SendNotificationT['method']): void;\n\n    /**\n     * A method to check if a request handler is supported by the local side, for the given method to be handled.\n     *\n     * This should be implemented by subclasses.\n     */\n    protected abstract assertRequestHandlerCapability(method: string): void;\n\n    /**\n     * Sends a request and wait for a response.\n     *\n     * Do not use this method to emit notifications! Use notification() instead.\n     */\n    request<T extends ZodType<object>>(request: SendRequestT, resultSchema: T, options?: RequestOptions): Promise<z.infer<T>> {\n        const { relatedRequestId, resumptionToken, onresumptiontoken } = options ?? {};\n\n        return new Promise((resolve, reject) => {\n            if (!this._transport) {\n                reject(new Error('Not connected'));\n                return;\n            }\n\n            if (this._options?.enforceStrictCapabilities === true) {\n                this.assertCapabilityForMethod(request.method);\n            }\n\n            options?.signal?.throwIfAborted();\n\n            const messageId = this._requestMessageId++;\n            const jsonrpcRequest: JSONRPCRequest = {\n                ...request,\n                jsonrpc: '2.0',\n                id: messageId\n            };\n\n            if (options?.onprogress) {\n                this._progressHandlers.set(messageId, options.onprogress);\n                jsonrpcRequest.params = {\n                    ...request.params,\n                    _meta: {\n                        ...(request.params?._meta || {}),\n                        progressToken: messageId\n                    }\n                };\n            }\n\n            const cancel = (reason: unknown) => {\n                this._responseHandlers.delete(messageId);\n                this._progressHandlers.delete(messageId);\n                this._cleanupTimeout(messageId);\n\n                this._transport\n                    ?.send(\n                        {\n                            jsonrpc: '2.0',\n                            method: 'notifications/cancelled',\n                            params: {\n                                requestId: messageId,\n                                reason: String(reason)\n                            }\n                        },\n                        { relatedRequestId, resumptionToken, onresumptiontoken }\n                    )\n                    .catch(error => this._onerror(new Error(`Failed to send cancellation: ${error}`)));\n\n                reject(reason);\n            };\n\n            this._responseHandlers.set(messageId, response => {\n                if (options?.signal?.aborted) {\n                    return;\n                }\n\n                if (response instanceof Error) {\n                    return reject(response);\n                }\n\n                try {\n                    const result = resultSchema.parse(response.result);\n                    resolve(result);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n\n            options?.signal?.addEventListener('abort', () => {\n                cancel(options?.signal?.reason);\n            });\n\n            const timeout = options?.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;\n            const timeoutHandler = () => cancel(new McpError(ErrorCode.RequestTimeout, 'Request timed out', { timeout }));\n\n            this._setupTimeout(messageId, timeout, options?.maxTotalTimeout, timeoutHandler, options?.resetTimeoutOnProgress ?? false);\n\n            this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch(error => {\n                this._cleanupTimeout(messageId);\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * Emits a notification, which is a one-way message that does not expect a response.\n     */\n    async notification(notification: SendNotificationT, options?: NotificationOptions): Promise<void> {\n        if (!this._transport) {\n            throw new Error('Not connected');\n        }\n\n        this.assertNotificationCapability(notification.method);\n\n        const debouncedMethods = this._options?.debouncedNotificationMethods ?? [];\n        // A notification can only be debounced if it's in the list AND it's \"simple\"\n        // (i.e., has no parameters and no related request ID that could be lost).\n        const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !options?.relatedRequestId;\n\n        if (canDebounce) {\n            // If a notification of this type is already scheduled, do nothing.\n            if (this._pendingDebouncedNotifications.has(notification.method)) {\n                return;\n            }\n\n            // Mark this notification type as pending.\n            this._pendingDebouncedNotifications.add(notification.method);\n\n            // Schedule the actual send to happen in the next microtask.\n            // This allows all synchronous calls in the current event loop tick to be coalesced.\n            Promise.resolve().then(() => {\n                // Un-mark the notification so the next one can be scheduled.\n                this._pendingDebouncedNotifications.delete(notification.method);\n\n                // SAFETY CHECK: If the connection was closed while this was pending, abort.\n                if (!this._transport) {\n                    return;\n                }\n\n                const jsonrpcNotification: JSONRPCNotification = {\n                    ...notification,\n                    jsonrpc: '2.0'\n                };\n                // Send the notification, but don't await it here to avoid blocking.\n                // Handle potential errors with a .catch().\n                this._transport?.send(jsonrpcNotification, options).catch(error => this._onerror(error));\n            });\n\n            // Return immediately.\n            return;\n        }\n\n        const jsonrpcNotification: JSONRPCNotification = {\n            ...notification,\n            jsonrpc: '2.0'\n        };\n\n        await this._transport.send(jsonrpcNotification, options);\n    }\n\n    /**\n     * Registers a handler to invoke when this protocol object receives a request with the given method.\n     *\n     * Note that this will replace any previous request handler for the same method.\n     */\n    setRequestHandler<\n        T extends ZodObject<{\n            method: ZodLiteral<string>;\n        }>\n    >(\n        requestSchema: T,\n        handler: (request: z.infer<T>, extra: RequestHandlerExtra<SendRequestT, SendNotificationT>) => SendResultT | Promise<SendResultT>\n    ): void {\n        const method = requestSchema.shape.method.value;\n        this.assertRequestHandlerCapability(method);\n\n        this._requestHandlers.set(method, (request, extra) => {\n            return Promise.resolve(handler(requestSchema.parse(request), extra));\n        });\n    }\n\n    /**\n     * Removes the request handler for the given method.\n     */\n    removeRequestHandler(method: string): void {\n        this._requestHandlers.delete(method);\n    }\n\n    /**\n     * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.\n     */\n    assertCanSetRequestHandler(method: string): void {\n        if (this._requestHandlers.has(method)) {\n            throw new Error(`A request handler for ${method} already exists, which would be overridden`);\n        }\n    }\n\n    /**\n     * Registers a handler to invoke when this protocol object receives a notification with the given method.\n     *\n     * Note that this will replace any previous notification handler for the same method.\n     */\n    setNotificationHandler<\n        T extends ZodObject<{\n            method: ZodLiteral<string>;\n        }>\n    >(notificationSchema: T, handler: (notification: z.infer<T>) => void | Promise<void>): void {\n        this._notificationHandlers.set(notificationSchema.shape.method.value, notification =>\n            Promise.resolve(handler(notificationSchema.parse(notification)))\n        );\n    }\n\n    /**\n     * Removes the notification handler for the given method.\n     */\n    removeNotificationHandler(method: string): void {\n        this._notificationHandlers.delete(method);\n    }\n}\n\nexport function mergeCapabilities<T extends ServerCapabilities | ClientCapabilities>(base: T, additional: T): T {\n    return Object.entries(additional).reduce(\n        (acc, [key, value]) => {\n            if (value && typeof value === 'object') {\n                acc[key] = acc[key] ? { ...acc[key], ...value } : value;\n            } else {\n                acc[key] = value;\n            }\n            return acc;\n        },\n        { ...base }\n    );\n}\n"],"names":["jsonrpcNotification"],"mappings":"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"}