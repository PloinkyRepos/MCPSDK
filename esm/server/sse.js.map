{"version":3,"file":"sse.js","sources":["../../../src/server/sse.ts"],"sourcesContent":["import { randomUUID } from 'node:crypto';\nimport { IncomingMessage, ServerResponse } from 'node:http';\nimport { Transport } from '../shared/transport.js';\nimport { JSONRPCMessage, JSONRPCMessageSchema, MessageExtraInfo, RequestInfo } from '../types.js';\nimport getRawBody from 'raw-body';\nimport contentType from 'content-type';\nimport { AuthInfo } from './auth/types.js';\nimport { URL } from 'url';\n\nconst MAXIMUM_MESSAGE_SIZE = '4mb';\n\n/**\n * Configuration options for SSEServerTransport.\n */\nexport interface SSEServerTransportOptions {\n    /**\n     * List of allowed host header values for DNS rebinding protection.\n     * If not specified, host validation is disabled.\n     */\n    allowedHosts?: string[];\n\n    /**\n     * List of allowed origin header values for DNS rebinding protection.\n     * If not specified, origin validation is disabled.\n     */\n    allowedOrigins?: string[];\n\n    /**\n     * Enable DNS rebinding protection (requires allowedHosts and/or allowedOrigins to be configured).\n     * Default is false for backwards compatibility.\n     */\n    enableDnsRebindingProtection?: boolean;\n}\n\n/**\n * Server transport for SSE: this will send messages over an SSE connection and receive messages from HTTP POST requests.\n *\n * This transport is only available in Node.js environments.\n */\nexport class SSEServerTransport implements Transport {\n    private _sseResponse?: ServerResponse;\n    private _sessionId: string;\n    private _options: SSEServerTransportOptions;\n    onclose?: () => void;\n    onerror?: (error: Error) => void;\n    onmessage?: (message: JSONRPCMessage, extra?: MessageExtraInfo) => void;\n\n    /**\n     * Creates a new SSE server transport, which will direct the client to POST messages to the relative or absolute URL identified by `_endpoint`.\n     */\n    constructor(\n        private _endpoint: string,\n        private res: ServerResponse,\n        options?: SSEServerTransportOptions\n    ) {\n        this._sessionId = randomUUID();\n        this._options = options || { enableDnsRebindingProtection: false };\n    }\n\n    /**\n     * Validates request headers for DNS rebinding protection.\n     * @returns Error message if validation fails, undefined if validation passes.\n     */\n    private validateRequestHeaders(req: IncomingMessage): string | undefined {\n        // Skip validation if protection is not enabled\n        if (!this._options.enableDnsRebindingProtection) {\n            return undefined;\n        }\n\n        // Validate Host header if allowedHosts is configured\n        if (this._options.allowedHosts && this._options.allowedHosts.length > 0) {\n            const hostHeader = req.headers.host;\n            if (!hostHeader || !this._options.allowedHosts.includes(hostHeader)) {\n                return `Invalid Host header: ${hostHeader}`;\n            }\n        }\n\n        // Validate Origin header if allowedOrigins is configured\n        if (this._options.allowedOrigins && this._options.allowedOrigins.length > 0) {\n            const originHeader = req.headers.origin;\n            if (!originHeader || !this._options.allowedOrigins.includes(originHeader)) {\n                return `Invalid Origin header: ${originHeader}`;\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Handles the initial SSE connection request.\n     *\n     * This should be called when a GET request is made to establish the SSE stream.\n     */\n    async start(): Promise<void> {\n        if (this._sseResponse) {\n            throw new Error('SSEServerTransport already started! If using Server class, note that connect() calls start() automatically.');\n        }\n\n        this.res.writeHead(200, {\n            'Content-Type': 'text/event-stream',\n            'Cache-Control': 'no-cache, no-transform',\n            Connection: 'keep-alive'\n        });\n\n        // Send the endpoint event\n        // Use a dummy base URL because this._endpoint is relative.\n        // This allows using URL/URLSearchParams for robust parameter handling.\n        const dummyBase = 'http://localhost'; // Any valid base works\n        const endpointUrl = new URL(this._endpoint, dummyBase);\n        endpointUrl.searchParams.set('sessionId', this._sessionId);\n\n        // Reconstruct the relative URL string (pathname + search + hash)\n        const relativeUrlWithSession = endpointUrl.pathname + endpointUrl.search + endpointUrl.hash;\n\n        this.res.write(`event: endpoint\\ndata: ${relativeUrlWithSession}\\n\\n`);\n\n        this._sseResponse = this.res;\n        this.res.on('close', () => {\n            this._sseResponse = undefined;\n            this.onclose?.();\n        });\n    }\n\n    /**\n     * Handles incoming POST messages.\n     *\n     * This should be called when a POST request is made to send a message to the server.\n     */\n    async handlePostMessage(req: IncomingMessage & { auth?: AuthInfo }, res: ServerResponse, parsedBody?: unknown): Promise<void> {\n        if (!this._sseResponse) {\n            const message = 'SSE connection not established';\n            res.writeHead(500).end(message);\n            throw new Error(message);\n        }\n\n        // Validate request headers for DNS rebinding protection\n        const validationError = this.validateRequestHeaders(req);\n        if (validationError) {\n            res.writeHead(403).end(validationError);\n            this.onerror?.(new Error(validationError));\n            return;\n        }\n\n        const authInfo: AuthInfo | undefined = req.auth;\n        const requestInfo: RequestInfo = { headers: req.headers };\n\n        let body: string | unknown;\n        try {\n            const ct = contentType.parse(req.headers['content-type'] ?? '');\n            if (ct.type !== 'application/json') {\n                throw new Error(`Unsupported content-type: ${ct.type}`);\n            }\n\n            body =\n                parsedBody ??\n                (await getRawBody(req, {\n                    limit: MAXIMUM_MESSAGE_SIZE,\n                    encoding: ct.parameters.charset ?? 'utf-8'\n                }));\n        } catch (error) {\n            res.writeHead(400).end(String(error));\n            this.onerror?.(error as Error);\n            return;\n        }\n\n        try {\n            await this.handleMessage(typeof body === 'string' ? JSON.parse(body) : body, { requestInfo, authInfo });\n        } catch {\n            res.writeHead(400).end(`Invalid message: ${body}`);\n            return;\n        }\n\n        res.writeHead(202).end('Accepted');\n    }\n\n    /**\n     * Handle a client message, regardless of how it arrived. This can be used to inform the server of messages that arrive via a means different than HTTP POST.\n     */\n    async handleMessage(message: unknown, extra?: MessageExtraInfo): Promise<void> {\n        let parsedMessage: JSONRPCMessage;\n        try {\n            parsedMessage = JSONRPCMessageSchema.parse(message);\n        } catch (error) {\n            this.onerror?.(error as Error);\n            throw error;\n        }\n\n        this.onmessage?.(parsedMessage, extra);\n    }\n\n    async close(): Promise<void> {\n        this._sseResponse?.end();\n        this._sseResponse = undefined;\n        this.onclose?.();\n    }\n\n    async send(message: JSONRPCMessage): Promise<void> {\n        if (!this._sseResponse) {\n            throw new Error('Not connected');\n        }\n\n        this._sseResponse.write(`event: message\\ndata: ${JSON.stringify(message)}\\n\\n`);\n    }\n\n    /**\n     * Returns the session ID for this transport.\n     *\n     * This can be used to route incoming POST requests.\n     */\n    get sessionId(): string {\n        return this._sessionId;\n    }\n}\n"],"names":[],"mappings":"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"}