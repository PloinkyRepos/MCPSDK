{"version":3,"file":"index.js","sources":["../../../src/server/index.ts"],"sourcesContent":["import { mergeCapabilities, Protocol, ProtocolOptions, RequestOptions } from '../shared/protocol.js';\nimport {\n    ClientCapabilities,\n    CreateMessageRequest,\n    CreateMessageResultSchema,\n    ElicitRequest,\n    ElicitResult,\n    ElicitResultSchema,\n    EmptyResultSchema,\n    Implementation,\n    InitializedNotificationSchema,\n    InitializeRequest,\n    InitializeRequestSchema,\n    InitializeResult,\n    LATEST_PROTOCOL_VERSION,\n    ListRootsRequest,\n    ListRootsResultSchema,\n    LoggingMessageNotification,\n    McpError,\n    ErrorCode,\n    Notification,\n    Request,\n    ResourceUpdatedNotification,\n    Result,\n    ServerCapabilities,\n    ServerNotification,\n    ServerRequest,\n    ServerResult,\n    SUPPORTED_PROTOCOL_VERSIONS,\n    LoggingLevel,\n    SetLevelRequestSchema,\n    LoggingLevelSchema\n} from '../types.js';\nimport Ajv from 'ajv';\n\nexport type ServerOptions = ProtocolOptions & {\n    /**\n     * Capabilities to advertise as being supported by this server.\n     */\n    capabilities?: ServerCapabilities;\n\n    /**\n     * Optional instructions describing how to use the server and its features.\n     */\n    instructions?: string;\n};\n\n/**\n * An MCP server on top of a pluggable transport.\n *\n * This server will automatically respond to the initialization flow as initiated from the client.\n *\n * To use with custom types, extend the base Request/Notification/Result types and pass them as type parameters:\n *\n * ```typescript\n * // Custom schemas\n * const CustomRequestSchema = RequestSchema.extend({...})\n * const CustomNotificationSchema = NotificationSchema.extend({...})\n * const CustomResultSchema = ResultSchema.extend({...})\n *\n * // Type aliases\n * type CustomRequest = z.infer<typeof CustomRequestSchema>\n * type CustomNotification = z.infer<typeof CustomNotificationSchema>\n * type CustomResult = z.infer<typeof CustomResultSchema>\n *\n * // Create typed server\n * const server = new Server<CustomRequest, CustomNotification, CustomResult>({\n *   name: \"CustomServer\",\n *   version: \"1.0.0\"\n * })\n * ```\n */\nexport class Server<\n    RequestT extends Request = Request,\n    NotificationT extends Notification = Notification,\n    ResultT extends Result = Result\n> extends Protocol<ServerRequest | RequestT, ServerNotification | NotificationT, ServerResult | ResultT> {\n    private _clientCapabilities?: ClientCapabilities;\n    private _clientVersion?: Implementation;\n    private _capabilities: ServerCapabilities;\n    private _instructions?: string;\n\n    /**\n     * Callback for when initialization has fully completed (i.e., the client has sent an `initialized` notification).\n     */\n    oninitialized?: () => void;\n\n    /**\n     * Initializes this server with the given name and version information.\n     */\n    constructor(\n        private _serverInfo: Implementation,\n        options?: ServerOptions\n    ) {\n        super(options);\n        this._capabilities = options?.capabilities ?? {};\n        this._instructions = options?.instructions;\n\n        this.setRequestHandler(InitializeRequestSchema, request => this._oninitialize(request));\n        this.setNotificationHandler(InitializedNotificationSchema, () => this.oninitialized?.());\n\n        if (this._capabilities.logging) {\n            this.setRequestHandler(SetLevelRequestSchema, async (request, extra) => {\n                const transportSessionId: string | undefined =\n                    extra.sessionId || (extra.requestInfo?.headers['mcp-session-id'] as string) || undefined;\n                const { level } = request.params;\n                const parseResult = LoggingLevelSchema.safeParse(level);\n                if (parseResult.success) {\n                    this._loggingLevels.set(transportSessionId, parseResult.data);\n                }\n                return {};\n            });\n        }\n    }\n\n    // Map log levels by session id\n    private _loggingLevels = new Map<string | undefined, LoggingLevel>();\n\n    // Map LogLevelSchema to severity index\n    private readonly LOG_LEVEL_SEVERITY = new Map(LoggingLevelSchema.options.map((level, index) => [level, index]));\n\n    // Is a message with the given level ignored in the log level set for the given session id?\n    private isMessageIgnored = (level: LoggingLevel, sessionId?: string): boolean => {\n        const currentLevel = this._loggingLevels.get(sessionId);\n        return currentLevel ? this.LOG_LEVEL_SEVERITY.get(level)! < this.LOG_LEVEL_SEVERITY.get(currentLevel)! : false;\n    };\n\n    /**\n     * Registers new capabilities. This can only be called before connecting to a transport.\n     *\n     * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).\n     */\n    public registerCapabilities(capabilities: ServerCapabilities): void {\n        if (this.transport) {\n            throw new Error('Cannot register capabilities after connecting to transport');\n        }\n        this._capabilities = mergeCapabilities(this._capabilities, capabilities);\n    }\n\n    protected assertCapabilityForMethod(method: RequestT['method']): void {\n        switch (method as ServerRequest['method']) {\n            case 'sampling/createMessage':\n                if (!this._clientCapabilities?.sampling) {\n                    throw new Error(`Client does not support sampling (required for ${method})`);\n                }\n                break;\n\n            case 'elicitation/create':\n                if (!this._clientCapabilities?.elicitation) {\n                    throw new Error(`Client does not support elicitation (required for ${method})`);\n                }\n                break;\n\n            case 'roots/list':\n                if (!this._clientCapabilities?.roots) {\n                    throw new Error(`Client does not support listing roots (required for ${method})`);\n                }\n                break;\n\n            case 'ping':\n                // No specific capability required for ping\n                break;\n        }\n    }\n\n    protected assertNotificationCapability(method: (ServerNotification | NotificationT)['method']): void {\n        switch (method as ServerNotification['method']) {\n            case 'notifications/message':\n                if (!this._capabilities.logging) {\n                    throw new Error(`Server does not support logging (required for ${method})`);\n                }\n                break;\n\n            case 'notifications/resources/updated':\n            case 'notifications/resources/list_changed':\n                if (!this._capabilities.resources) {\n                    throw new Error(`Server does not support notifying about resources (required for ${method})`);\n                }\n                break;\n\n            case 'notifications/tools/list_changed':\n                if (!this._capabilities.tools) {\n                    throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);\n                }\n                break;\n\n            case 'notifications/prompts/list_changed':\n                if (!this._capabilities.prompts) {\n                    throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);\n                }\n                break;\n\n            case 'notifications/cancelled':\n                // Cancellation notifications are always allowed\n                break;\n\n            case 'notifications/progress':\n                // Progress notifications are always allowed\n                break;\n        }\n    }\n\n    protected assertRequestHandlerCapability(method: string): void {\n        switch (method) {\n            case 'sampling/createMessage':\n                if (!this._capabilities.sampling) {\n                    throw new Error(`Server does not support sampling (required for ${method})`);\n                }\n                break;\n\n            case 'logging/setLevel':\n                if (!this._capabilities.logging) {\n                    throw new Error(`Server does not support logging (required for ${method})`);\n                }\n                break;\n\n            case 'prompts/get':\n            case 'prompts/list':\n                if (!this._capabilities.prompts) {\n                    throw new Error(`Server does not support prompts (required for ${method})`);\n                }\n                break;\n\n            case 'resources/list':\n            case 'resources/templates/list':\n            case 'resources/read':\n                if (!this._capabilities.resources) {\n                    throw new Error(`Server does not support resources (required for ${method})`);\n                }\n                break;\n\n            case 'tools/call':\n            case 'tools/list':\n                if (!this._capabilities.tools) {\n                    throw new Error(`Server does not support tools (required for ${method})`);\n                }\n                break;\n\n            case 'ping':\n            case 'initialize':\n                // No specific capability required for these methods\n                break;\n        }\n    }\n\n    private async _oninitialize(request: InitializeRequest): Promise<InitializeResult> {\n        const requestedVersion = request.params.protocolVersion;\n\n        this._clientCapabilities = request.params.capabilities;\n        this._clientVersion = request.params.clientInfo;\n\n        const protocolVersion = SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION;\n\n        return {\n            protocolVersion,\n            capabilities: this.getCapabilities(),\n            serverInfo: this._serverInfo,\n            ...(this._instructions && { instructions: this._instructions })\n        };\n    }\n\n    /**\n     * After initialization has completed, this will be populated with the client's reported capabilities.\n     */\n    getClientCapabilities(): ClientCapabilities | undefined {\n        return this._clientCapabilities;\n    }\n\n    /**\n     * After initialization has completed, this will be populated with information about the client's name and version.\n     */\n    getClientVersion(): Implementation | undefined {\n        return this._clientVersion;\n    }\n\n    private getCapabilities(): ServerCapabilities {\n        return this._capabilities;\n    }\n\n    async ping() {\n        return this.request({ method: 'ping' }, EmptyResultSchema);\n    }\n\n    async createMessage(params: CreateMessageRequest['params'], options?: RequestOptions) {\n        return this.request({ method: 'sampling/createMessage', params }, CreateMessageResultSchema, options);\n    }\n\n    async elicitInput(params: ElicitRequest['params'], options?: RequestOptions): Promise<ElicitResult> {\n        const result = await this.request({ method: 'elicitation/create', params }, ElicitResultSchema, options);\n\n        // Validate the response content against the requested schema if action is \"accept\"\n        if (result.action === 'accept' && result.content) {\n            try {\n                const ajv = new Ajv();\n\n                const validate = ajv.compile(params.requestedSchema);\n                const isValid = validate(result.content);\n\n                if (!isValid) {\n                    throw new McpError(\n                        ErrorCode.InvalidParams,\n                        `Elicitation response content does not match requested schema: ${ajv.errorsText(validate.errors)}`\n                    );\n                }\n            } catch (error) {\n                if (error instanceof McpError) {\n                    throw error;\n                }\n                throw new McpError(ErrorCode.InternalError, `Error validating elicitation response: ${error}`);\n            }\n        }\n\n        return result;\n    }\n\n    async listRoots(params?: ListRootsRequest['params'], options?: RequestOptions) {\n        return this.request({ method: 'roots/list', params }, ListRootsResultSchema, options);\n    }\n\n    /**\n     * Sends a logging message to the client, if connected.\n     * Note: You only need to send the parameters object, not the entire JSON RPC message\n     * @see LoggingMessageNotification\n     * @param params\n     * @param sessionId optional for stateless and backward compatibility\n     */\n    async sendLoggingMessage(params: LoggingMessageNotification['params'], sessionId?: string) {\n        if (this._capabilities.logging) {\n            if (!this.isMessageIgnored(params.level, sessionId)) {\n                return this.notification({ method: 'notifications/message', params });\n            }\n        }\n    }\n\n    async sendResourceUpdated(params: ResourceUpdatedNotification['params']) {\n        return this.notification({\n            method: 'notifications/resources/updated',\n            params\n        });\n    }\n\n    async sendResourceListChanged() {\n        return this.notification({\n            method: 'notifications/resources/list_changed'\n        });\n    }\n\n    async sendToolListChanged() {\n        return this.notification({ method: 'notifications/tools/list_changed' });\n    }\n\n    async sendPromptListChanged() {\n        return this.notification({ method: 'notifications/prompts/list_changed' });\n    }\n}\n"],"names":[],"mappings":"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"}