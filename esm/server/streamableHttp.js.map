{"version":3,"file":"streamableHttp.js","sources":["../../../src/server/streamableHttp.ts"],"sourcesContent":["import { IncomingMessage, ServerResponse } from 'node:http';\nimport { Transport } from '../shared/transport.js';\nimport {\n    MessageExtraInfo,\n    RequestInfo,\n    isInitializeRequest,\n    isJSONRPCError,\n    isJSONRPCRequest,\n    isJSONRPCResponse,\n    JSONRPCMessage,\n    JSONRPCMessageSchema,\n    RequestId,\n    SUPPORTED_PROTOCOL_VERSIONS,\n    DEFAULT_NEGOTIATED_PROTOCOL_VERSION\n} from '../types.js';\nimport getRawBody from 'raw-body';\nimport contentType from 'content-type';\nimport { randomUUID } from 'node:crypto';\nimport { AuthInfo } from './auth/types.js';\n\nconst MAXIMUM_MESSAGE_SIZE = '4mb';\n\nexport type StreamId = string;\nexport type EventId = string;\n\n/**\n * Interface for resumability support via event storage\n */\nexport interface EventStore {\n    /**\n     * Stores an event for later retrieval\n     * @param streamId ID of the stream the event belongs to\n     * @param message The JSON-RPC message to store\n     * @returns The generated event ID for the stored event\n     */\n    storeEvent(streamId: StreamId, message: JSONRPCMessage): Promise<EventId>;\n\n    replayEventsAfter(\n        lastEventId: EventId,\n        {\n            send\n        }: {\n            send: (eventId: EventId, message: JSONRPCMessage) => Promise<void>;\n        }\n    ): Promise<StreamId>;\n}\n\n/**\n * Configuration options for StreamableHTTPServerTransport\n */\nexport interface StreamableHTTPServerTransportOptions {\n    /**\n     * Function that generates a session ID for the transport.\n     * The session ID SHOULD be globally unique and cryptographically secure (e.g., a securely generated UUID, a JWT, or a cryptographic hash)\n     *\n     * Return undefined to disable session management.\n     */\n    sessionIdGenerator: (() => string) | undefined;\n\n    /**\n     * A callback for session initialization events\n     * This is called when the server initializes a new session.\n     * Useful in cases when you need to register multiple mcp sessions\n     * and need to keep track of them.\n     * @param sessionId The generated session ID\n     */\n    onsessioninitialized?: (sessionId: string) => void | Promise<void>;\n\n    /**\n     * A callback for session close events\n     * This is called when the server closes a session due to a DELETE request.\n     * Useful in cases when you need to clean up resources associated with the session.\n     * Note that this is different from the transport closing, if you are handling\n     * HTTP requests from multiple nodes you might want to close each\n     * StreamableHTTPServerTransport after a request is completed while still keeping the\n     * session open/running.\n     * @param sessionId The session ID that was closed\n     */\n    onsessionclosed?: (sessionId: string) => void | Promise<void>;\n\n    /**\n     * If true, the server will return JSON responses instead of starting an SSE stream.\n     * This can be useful for simple request/response scenarios without streaming.\n     * Default is false (SSE streams are preferred).\n     */\n    enableJsonResponse?: boolean;\n\n    /**\n     * Event store for resumability support\n     * If provided, resumability will be enabled, allowing clients to reconnect and resume messages\n     */\n    eventStore?: EventStore;\n\n    /**\n     * List of allowed host header values for DNS rebinding protection.\n     * If not specified, host validation is disabled.\n     */\n    allowedHosts?: string[];\n\n    /**\n     * List of allowed origin header values for DNS rebinding protection.\n     * If not specified, origin validation is disabled.\n     */\n    allowedOrigins?: string[];\n\n    /**\n     * Enable DNS rebinding protection (requires allowedHosts and/or allowedOrigins to be configured).\n     * Default is false for backwards compatibility.\n     */\n    enableDnsRebindingProtection?: boolean;\n}\n\n/**\n * Server transport for Streamable HTTP: this implements the MCP Streamable HTTP transport specification.\n * It supports both SSE streaming and direct HTTP responses.\n *\n * Usage example:\n *\n * ```typescript\n * // Stateful mode - server sets the session ID\n * const statefulTransport = new StreamableHTTPServerTransport({\n *   sessionIdGenerator: () => randomUUID(),\n * });\n *\n * // Stateless mode - explicitly set session ID to undefined\n * const statelessTransport = new StreamableHTTPServerTransport({\n *   sessionIdGenerator: undefined,\n * });\n *\n * // Using with pre-parsed request body\n * app.post('/mcp', (req, res) => {\n *   transport.handleRequest(req, res, req.body);\n * });\n * ```\n *\n * In stateful mode:\n * - Session ID is generated and included in response headers\n * - Session ID is always included in initialization responses\n * - Requests with invalid session IDs are rejected with 404 Not Found\n * - Non-initialization requests without a session ID are rejected with 400 Bad Request\n * - State is maintained in-memory (connections, message history)\n *\n * In stateless mode:\n * - No Session ID is included in any responses\n * - No session validation is performed\n */\nexport class StreamableHTTPServerTransport implements Transport {\n    // when sessionId is not set (undefined), it means the transport is in stateless mode\n    private sessionIdGenerator: (() => string) | undefined;\n    private _started: boolean = false;\n    private _streamMapping: Map<string, ServerResponse> = new Map();\n    private _requestToStreamMapping: Map<RequestId, string> = new Map();\n    private _requestResponseMap: Map<RequestId, JSONRPCMessage> = new Map();\n    private _initialized: boolean = false;\n    private _enableJsonResponse: boolean = false;\n    private _standaloneSseStreamId: string = '_GET_stream';\n    private _eventStore?: EventStore;\n    private _onsessioninitialized?: (sessionId: string) => void | Promise<void>;\n    private _onsessionclosed?: (sessionId: string) => void | Promise<void>;\n    private _allowedHosts?: string[];\n    private _allowedOrigins?: string[];\n    private _enableDnsRebindingProtection: boolean;\n\n    sessionId?: string;\n    onclose?: () => void;\n    onerror?: (error: Error) => void;\n    onmessage?: (message: JSONRPCMessage, extra?: MessageExtraInfo) => void;\n\n    constructor(options: StreamableHTTPServerTransportOptions) {\n        this.sessionIdGenerator = options.sessionIdGenerator;\n        this._enableJsonResponse = options.enableJsonResponse ?? false;\n        this._eventStore = options.eventStore;\n        this._onsessioninitialized = options.onsessioninitialized;\n        this._onsessionclosed = options.onsessionclosed;\n        this._allowedHosts = options.allowedHosts;\n        this._allowedOrigins = options.allowedOrigins;\n        this._enableDnsRebindingProtection = options.enableDnsRebindingProtection ?? false;\n    }\n\n    /**\n     * Starts the transport. This is required by the Transport interface but is a no-op\n     * for the Streamable HTTP transport as connections are managed per-request.\n     */\n    async start(): Promise<void> {\n        if (this._started) {\n            throw new Error('Transport already started');\n        }\n        this._started = true;\n    }\n\n    /**\n     * Validates request headers for DNS rebinding protection.\n     * @returns Error message if validation fails, undefined if validation passes.\n     */\n    private validateRequestHeaders(req: IncomingMessage): string | undefined {\n        // Skip validation if protection is not enabled\n        if (!this._enableDnsRebindingProtection) {\n            return undefined;\n        }\n\n        // Validate Host header if allowedHosts is configured\n        if (this._allowedHosts && this._allowedHosts.length > 0) {\n            const hostHeader = req.headers.host;\n            if (!hostHeader || !this._allowedHosts.includes(hostHeader)) {\n                return `Invalid Host header: ${hostHeader}`;\n            }\n        }\n\n        // Validate Origin header if allowedOrigins is configured\n        if (this._allowedOrigins && this._allowedOrigins.length > 0) {\n            const originHeader = req.headers.origin;\n            if (!originHeader || !this._allowedOrigins.includes(originHeader)) {\n                return `Invalid Origin header: ${originHeader}`;\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Handles an incoming HTTP request, whether GET or POST\n     */\n    async handleRequest(req: IncomingMessage & { auth?: AuthInfo }, res: ServerResponse, parsedBody?: unknown): Promise<void> {\n        // Validate request headers for DNS rebinding protection\n        const validationError = this.validateRequestHeaders(req);\n        if (validationError) {\n            res.writeHead(403).end(\n                JSON.stringify({\n                    jsonrpc: '2.0',\n                    error: {\n                        code: -32000,\n                        message: validationError\n                    },\n                    id: null\n                })\n            );\n            this.onerror?.(new Error(validationError));\n            return;\n        }\n\n        if (req.method === 'POST') {\n            await this.handlePostRequest(req, res, parsedBody);\n        } else if (req.method === 'GET') {\n            await this.handleGetRequest(req, res);\n        } else if (req.method === 'DELETE') {\n            await this.handleDeleteRequest(req, res);\n        } else {\n            await this.handleUnsupportedRequest(res);\n        }\n    }\n\n    /**\n     * Handles GET requests for SSE stream\n     */\n    private async handleGetRequest(req: IncomingMessage, res: ServerResponse): Promise<void> {\n        // The client MUST include an Accept header, listing text/event-stream as a supported content type.\n        const acceptHeader = req.headers.accept;\n        if (!acceptHeader?.includes('text/event-stream')) {\n            res.writeHead(406).end(\n                JSON.stringify({\n                    jsonrpc: '2.0',\n                    error: {\n                        code: -32000,\n                        message: 'Not Acceptable: Client must accept text/event-stream'\n                    },\n                    id: null\n                })\n            );\n            return;\n        }\n\n        // If an Mcp-Session-Id is returned by the server during initialization,\n        // clients using the Streamable HTTP transport MUST include it\n        // in the Mcp-Session-Id header on all of their subsequent HTTP requests.\n        if (!this.validateSession(req, res)) {\n            return;\n        }\n        if (!this.validateProtocolVersion(req, res)) {\n            return;\n        }\n        // Handle resumability: check for Last-Event-ID header\n        if (this._eventStore) {\n            const lastEventId = req.headers['last-event-id'] as string | undefined;\n            if (lastEventId) {\n                await this.replayEvents(lastEventId, res);\n                return;\n            }\n        }\n\n        // The server MUST either return Content-Type: text/event-stream in response to this HTTP GET,\n        // or else return HTTP 405 Method Not Allowed\n        const headers: Record<string, string> = {\n            'Content-Type': 'text/event-stream',\n            'Cache-Control': 'no-cache, no-transform',\n            Connection: 'keep-alive'\n        };\n\n        // After initialization, always include the session ID if we have one\n        if (this.sessionId !== undefined) {\n            headers['mcp-session-id'] = this.sessionId;\n        }\n\n        // Check if there's already an active standalone SSE stream for this session\n        if (this._streamMapping.get(this._standaloneSseStreamId) !== undefined) {\n            // Only one GET SSE stream is allowed per session\n            res.writeHead(409).end(\n                JSON.stringify({\n                    jsonrpc: '2.0',\n                    error: {\n                        code: -32000,\n                        message: 'Conflict: Only one SSE stream is allowed per session'\n                    },\n                    id: null\n                })\n            );\n            return;\n        }\n\n        // We need to send headers immediately as messages will arrive much later,\n        // otherwise the client will just wait for the first message\n        res.writeHead(200, headers).flushHeaders();\n\n        // Assign the response to the standalone SSE stream\n        this._streamMapping.set(this._standaloneSseStreamId, res);\n        // Set up close handler for client disconnects\n        res.on('close', () => {\n            this._streamMapping.delete(this._standaloneSseStreamId);\n        });\n\n        // Add error handler for standalone SSE stream\n        res.on('error', error => {\n            this.onerror?.(error as Error);\n        });\n    }\n\n    /**\n     * Replays events that would have been sent after the specified event ID\n     * Only used when resumability is enabled\n     */\n    private async replayEvents(lastEventId: string, res: ServerResponse): Promise<void> {\n        if (!this._eventStore) {\n            return;\n        }\n        try {\n            const headers: Record<string, string> = {\n                'Content-Type': 'text/event-stream',\n                'Cache-Control': 'no-cache, no-transform',\n                Connection: 'keep-alive'\n            };\n\n            if (this.sessionId !== undefined) {\n                headers['mcp-session-id'] = this.sessionId;\n            }\n            res.writeHead(200, headers).flushHeaders();\n\n            const streamId = await this._eventStore?.replayEventsAfter(lastEventId, {\n                send: async (eventId: string, message: JSONRPCMessage) => {\n                    if (!this.writeSSEEvent(res, message, eventId)) {\n                        this.onerror?.(new Error('Failed replay events'));\n                        res.end();\n                    }\n                }\n            });\n            this._streamMapping.set(streamId, res);\n\n            // Add error handler for replay stream\n            res.on('error', error => {\n                this.onerror?.(error as Error);\n            });\n        } catch (error) {\n            this.onerror?.(error as Error);\n        }\n    }\n\n    /**\n     * Writes an event to the SSE stream with proper formatting\n     */\n    private writeSSEEvent(res: ServerResponse, message: JSONRPCMessage, eventId?: string): boolean {\n        let eventData = `event: message\\n`;\n        // Include event ID if provided - this is important for resumability\n        if (eventId) {\n            eventData += `id: ${eventId}\\n`;\n        }\n        eventData += `data: ${JSON.stringify(message)}\\n\\n`;\n\n        return res.write(eventData);\n    }\n\n    /**\n     * Handles unsupported requests (PUT, PATCH, etc.)\n     */\n    private async handleUnsupportedRequest(res: ServerResponse): Promise<void> {\n        res.writeHead(405, {\n            Allow: 'GET, POST, DELETE'\n        }).end(\n            JSON.stringify({\n                jsonrpc: '2.0',\n                error: {\n                    code: -32000,\n                    message: 'Method not allowed.'\n                },\n                id: null\n            })\n        );\n    }\n\n    /**\n     * Handles POST requests containing JSON-RPC messages\n     */\n    private async handlePostRequest(req: IncomingMessage & { auth?: AuthInfo }, res: ServerResponse, parsedBody?: unknown): Promise<void> {\n        try {\n            // Validate the Accept header\n            const acceptHeader = req.headers.accept;\n            // The client MUST include an Accept header, listing both application/json and text/event-stream as supported content types.\n            if (!acceptHeader?.includes('application/json') || !acceptHeader.includes('text/event-stream')) {\n                res.writeHead(406).end(\n                    JSON.stringify({\n                        jsonrpc: '2.0',\n                        error: {\n                            code: -32000,\n                            message: 'Not Acceptable: Client must accept both application/json and text/event-stream'\n                        },\n                        id: null\n                    })\n                );\n                return;\n            }\n\n            const ct = req.headers['content-type'];\n            if (!ct || !ct.includes('application/json')) {\n                res.writeHead(415).end(\n                    JSON.stringify({\n                        jsonrpc: '2.0',\n                        error: {\n                            code: -32000,\n                            message: 'Unsupported Media Type: Content-Type must be application/json'\n                        },\n                        id: null\n                    })\n                );\n                return;\n            }\n\n            const authInfo: AuthInfo | undefined = req.auth;\n            const requestInfo: RequestInfo = { headers: req.headers };\n\n            let rawMessage;\n            if (parsedBody !== undefined) {\n                rawMessage = parsedBody;\n            } else {\n                const parsedCt = contentType.parse(ct);\n                const body = await getRawBody(req, {\n                    limit: MAXIMUM_MESSAGE_SIZE,\n                    encoding: parsedCt.parameters.charset ?? 'utf-8'\n                });\n                rawMessage = JSON.parse(body.toString());\n            }\n\n            let messages: JSONRPCMessage[];\n\n            // handle batch and single messages\n            if (Array.isArray(rawMessage)) {\n                messages = rawMessage.map(msg => JSONRPCMessageSchema.parse(msg));\n            } else {\n                messages = [JSONRPCMessageSchema.parse(rawMessage)];\n            }\n\n            // Check if this is an initialization request\n            // https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/lifecycle/\n            const isInitializationRequest = messages.some(isInitializeRequest);\n            if (isInitializationRequest) {\n                // If it's a server with session management and the session ID is already set we should reject the request\n                // to avoid re-initialization.\n                if (this._initialized && this.sessionId !== undefined) {\n                    res.writeHead(400).end(\n                        JSON.stringify({\n                            jsonrpc: '2.0',\n                            error: {\n                                code: -32600,\n                                message: 'Invalid Request: Server already initialized'\n                            },\n                            id: null\n                        })\n                    );\n                    return;\n                }\n                if (messages.length > 1) {\n                    res.writeHead(400).end(\n                        JSON.stringify({\n                            jsonrpc: '2.0',\n                            error: {\n                                code: -32600,\n                                message: 'Invalid Request: Only one initialization request is allowed'\n                            },\n                            id: null\n                        })\n                    );\n                    return;\n                }\n                this.sessionId = this.sessionIdGenerator?.();\n                this._initialized = true;\n\n                // If we have a session ID and an onsessioninitialized handler, call it immediately\n                // This is needed in cases where the server needs to keep track of multiple sessions\n                if (this.sessionId && this._onsessioninitialized) {\n                    await Promise.resolve(this._onsessioninitialized(this.sessionId));\n                }\n            }\n            if (!isInitializationRequest) {\n                // If an Mcp-Session-Id is returned by the server during initialization,\n                // clients using the Streamable HTTP transport MUST include it\n                // in the Mcp-Session-Id header on all of their subsequent HTTP requests.\n                if (!this.validateSession(req, res)) {\n                    return;\n                }\n                // Mcp-Protocol-Version header is required for all requests after initialization.\n                if (!this.validateProtocolVersion(req, res)) {\n                    return;\n                }\n            }\n\n            // check if it contains requests\n            const hasRequests = messages.some(isJSONRPCRequest);\n\n            if (!hasRequests) {\n                // if it only contains notifications or responses, return 202\n                res.writeHead(202).end();\n\n                // handle each message\n                for (const message of messages) {\n                    this.onmessage?.(message, { authInfo, requestInfo });\n                }\n            } else if (hasRequests) {\n                // The default behavior is to use SSE streaming\n                // but in some cases server will return JSON responses\n                const streamId = randomUUID();\n                if (!this._enableJsonResponse) {\n                    const headers: Record<string, string> = {\n                        'Content-Type': 'text/event-stream',\n                        'Cache-Control': 'no-cache',\n                        Connection: 'keep-alive'\n                    };\n\n                    // After initialization, always include the session ID if we have one\n                    if (this.sessionId !== undefined) {\n                        headers['mcp-session-id'] = this.sessionId;\n                    }\n\n                    res.writeHead(200, headers);\n                }\n                // Store the response for this request to send messages back through this connection\n                // We need to track by request ID to maintain the connection\n                for (const message of messages) {\n                    if (isJSONRPCRequest(message)) {\n                        this._streamMapping.set(streamId, res);\n                        this._requestToStreamMapping.set(message.id, streamId);\n                    }\n                }\n                // Set up close handler for client disconnects\n                res.on('close', () => {\n                    this._streamMapping.delete(streamId);\n                });\n\n                // Add error handler for stream write errors\n                res.on('error', error => {\n                    this.onerror?.(error as Error);\n                });\n\n                // handle each message\n                for (const message of messages) {\n                    this.onmessage?.(message, { authInfo, requestInfo });\n                }\n                // The server SHOULD NOT close the SSE stream before sending all JSON-RPC responses\n                // This will be handled by the send() method when responses are ready\n            }\n        } catch (error) {\n            // return JSON-RPC formatted error\n            res.writeHead(400).end(\n                JSON.stringify({\n                    jsonrpc: '2.0',\n                    error: {\n                        code: -32700,\n                        message: 'Parse error',\n                        data: String(error)\n                    },\n                    id: null\n                })\n            );\n            this.onerror?.(error as Error);\n        }\n    }\n\n    /**\n     * Handles DELETE requests to terminate sessions\n     */\n    private async handleDeleteRequest(req: IncomingMessage, res: ServerResponse): Promise<void> {\n        if (!this.validateSession(req, res)) {\n            return;\n        }\n        if (!this.validateProtocolVersion(req, res)) {\n            return;\n        }\n        await Promise.resolve(this._onsessionclosed?.(this.sessionId!));\n        await this.close();\n        res.writeHead(200).end();\n    }\n\n    /**\n     * Validates session ID for non-initialization requests\n     * Returns true if the session is valid, false otherwise\n     */\n    private validateSession(req: IncomingMessage, res: ServerResponse): boolean {\n        if (this.sessionIdGenerator === undefined) {\n            // If the sessionIdGenerator ID is not set, the session management is disabled\n            // and we don't need to validate the session ID\n            return true;\n        }\n        if (!this._initialized) {\n            // If the server has not been initialized yet, reject all requests\n            res.writeHead(400).end(\n                JSON.stringify({\n                    jsonrpc: '2.0',\n                    error: {\n                        code: -32000,\n                        message: 'Bad Request: Server not initialized'\n                    },\n                    id: null\n                })\n            );\n            return false;\n        }\n\n        const sessionId = req.headers['mcp-session-id'];\n\n        if (!sessionId) {\n            // Non-initialization requests without a session ID should return 400 Bad Request\n            res.writeHead(400).end(\n                JSON.stringify({\n                    jsonrpc: '2.0',\n                    error: {\n                        code: -32000,\n                        message: 'Bad Request: Mcp-Session-Id header is required'\n                    },\n                    id: null\n                })\n            );\n            return false;\n        } else if (Array.isArray(sessionId)) {\n            res.writeHead(400).end(\n                JSON.stringify({\n                    jsonrpc: '2.0',\n                    error: {\n                        code: -32000,\n                        message: 'Bad Request: Mcp-Session-Id header must be a single value'\n                    },\n                    id: null\n                })\n            );\n            return false;\n        } else if (sessionId !== this.sessionId) {\n            // Reject requests with invalid session ID with 404 Not Found\n            res.writeHead(404).end(\n                JSON.stringify({\n                    jsonrpc: '2.0',\n                    error: {\n                        code: -32001,\n                        message: 'Session not found'\n                    },\n                    id: null\n                })\n            );\n            return false;\n        }\n\n        return true;\n    }\n\n    private validateProtocolVersion(req: IncomingMessage, res: ServerResponse): boolean {\n        let protocolVersion = req.headers['mcp-protocol-version'] ?? DEFAULT_NEGOTIATED_PROTOCOL_VERSION;\n        if (Array.isArray(protocolVersion)) {\n            protocolVersion = protocolVersion[protocolVersion.length - 1];\n        }\n\n        if (!SUPPORTED_PROTOCOL_VERSIONS.includes(protocolVersion)) {\n            res.writeHead(400).end(\n                JSON.stringify({\n                    jsonrpc: '2.0',\n                    error: {\n                        code: -32000,\n                        message: `Bad Request: Unsupported protocol version (supported versions: ${SUPPORTED_PROTOCOL_VERSIONS.join(', ')})`\n                    },\n                    id: null\n                })\n            );\n            return false;\n        }\n        return true;\n    }\n\n    async close(): Promise<void> {\n        // Close all SSE connections\n        this._streamMapping.forEach(response => {\n            response.end();\n        });\n        this._streamMapping.clear();\n\n        // Clear any pending responses\n        this._requestResponseMap.clear();\n        this.onclose?.();\n    }\n\n    async send(message: JSONRPCMessage, options?: { relatedRequestId?: RequestId }): Promise<void> {\n        let requestId = options?.relatedRequestId;\n        if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n            // If the message is a response, use the request ID from the message\n            requestId = message.id;\n        }\n\n        // Check if this message should be sent on the standalone SSE stream (no request ID)\n        // Ignore notifications from tools (which have relatedRequestId set)\n        // Those will be sent via dedicated response SSE streams\n        if (requestId === undefined) {\n            // For standalone SSE streams, we can only send requests and notifications\n            if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n                throw new Error('Cannot send a response on a standalone SSE stream unless resuming a previous client request');\n            }\n            const standaloneSse = this._streamMapping.get(this._standaloneSseStreamId);\n            if (standaloneSse === undefined) {\n                // The spec says the server MAY send messages on the stream, so it's ok to discard if no stream\n                return;\n            }\n\n            // Generate and store event ID if event store is provided\n            let eventId: string | undefined;\n            if (this._eventStore) {\n                // Stores the event and gets the generated event ID\n                eventId = await this._eventStore.storeEvent(this._standaloneSseStreamId, message);\n            }\n\n            // Send the message to the standalone SSE stream\n            this.writeSSEEvent(standaloneSse, message, eventId);\n            return;\n        }\n\n        // Get the response for this request\n        const streamId = this._requestToStreamMapping.get(requestId);\n        const response = this._streamMapping.get(streamId!);\n        if (!streamId) {\n            throw new Error(`No connection established for request ID: ${String(requestId)}`);\n        }\n\n        if (!this._enableJsonResponse) {\n            // For SSE responses, generate event ID if event store is provided\n            let eventId: string | undefined;\n\n            if (this._eventStore) {\n                eventId = await this._eventStore.storeEvent(streamId, message);\n            }\n            if (response) {\n                // Write the event to the response stream\n                this.writeSSEEvent(response, message, eventId);\n            }\n        }\n\n        if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n            this._requestResponseMap.set(requestId, message);\n            const relatedIds = Array.from(this._requestToStreamMapping.entries())\n                .filter(([_, streamId]) => this._streamMapping.get(streamId) === response)\n                .map(([id]) => id);\n\n            // Check if we have responses for all requests using this connection\n            const allResponsesReady = relatedIds.every(id => this._requestResponseMap.has(id));\n\n            if (allResponsesReady) {\n                if (!response) {\n                    throw new Error(`No connection established for request ID: ${String(requestId)}`);\n                }\n                if (this._enableJsonResponse) {\n                    // All responses ready, send as JSON\n                    const headers: Record<string, string> = {\n                        'Content-Type': 'application/json'\n                    };\n                    if (this.sessionId !== undefined) {\n                        headers['mcp-session-id'] = this.sessionId;\n                    }\n\n                    const responses = relatedIds.map(id => this._requestResponseMap.get(id)!);\n\n                    response.writeHead(200, headers);\n                    if (responses.length === 1) {\n                        response.end(JSON.stringify(responses[0]));\n                    } else {\n                        response.end(JSON.stringify(responses));\n                    }\n                } else {\n                    // End the SSE stream\n                    response.end();\n                }\n                // Clean up\n                for (const id of relatedIds) {\n                    this._requestResponseMap.delete(id);\n                    this._requestToStreamMapping.delete(id);\n                }\n            }\n        }\n    }\n}\n"],"names":["streamId"],"mappings":"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"}