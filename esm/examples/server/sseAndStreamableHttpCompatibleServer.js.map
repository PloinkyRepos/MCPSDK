{"version":3,"file":"sseAndStreamableHttpCompatibleServer.js","sources":["../../../../src/examples/server/sseAndStreamableHttpCompatibleServer.ts"],"sourcesContent":["import express, { Request, Response } from 'express';\nimport { randomUUID } from 'node:crypto';\nimport { McpServer } from '../../server/mcp.js';\nimport { StreamableHTTPServerTransport } from '../../server/streamableHttp.js';\nimport { SSEServerTransport } from '../../server/sse.js';\nimport { z } from 'zod';\nimport { CallToolResult, isInitializeRequest } from '../../types.js';\nimport { InMemoryEventStore } from '../shared/inMemoryEventStore.js';\nimport cors from 'cors';\n\n/**\n * This example server demonstrates backwards compatibility with both:\n * 1. The deprecated HTTP+SSE transport (protocol version 2024-11-05)\n * 2. The Streamable HTTP transport (protocol version 2025-03-26)\n *\n * It maintains a single MCP server instance but exposes two transport options:\n * - /mcp: The new Streamable HTTP endpoint (supports GET/POST/DELETE)\n * - /sse: The deprecated SSE endpoint for older clients (GET to establish stream)\n * - /messages: The deprecated POST endpoint for older clients (POST to send messages)\n */\n\nconst getServer = () => {\n    const server = new McpServer(\n        {\n            name: 'backwards-compatible-server',\n            version: '1.0.0'\n        },\n        { capabilities: { logging: {} } }\n    );\n\n    // Register a simple tool that sends notifications over time\n    server.tool(\n        'start-notification-stream',\n        'Starts sending periodic notifications for testing resumability',\n        {\n            interval: z.number().describe('Interval in milliseconds between notifications').default(100),\n            count: z.number().describe('Number of notifications to send (0 for 100)').default(50)\n        },\n        async ({ interval, count }, extra): Promise<CallToolResult> => {\n            const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n            let counter = 0;\n\n            while (count === 0 || counter < count) {\n                counter++;\n                try {\n                    await server.sendLoggingMessage(\n                        {\n                            level: 'info',\n                            data: `Periodic notification #${counter} at ${new Date().toISOString()}`\n                        },\n                        extra.sessionId\n                    );\n                } catch (error) {\n                    console.error('Error sending notification:', error);\n                }\n                // Wait for the specified interval\n                await sleep(interval);\n            }\n\n            return {\n                content: [\n                    {\n                        type: 'text',\n                        text: `Started sending periodic notifications every ${interval}ms`\n                    }\n                ]\n            };\n        }\n    );\n    return server;\n};\n\n// Create Express application\nconst app = express();\napp.use(express.json());\n\n// Configure CORS to expose Mcp-Session-Id header for browser-based clients\napp.use(\n    cors({\n        origin: '*', // Allow all origins - adjust as needed for production\n        exposedHeaders: ['Mcp-Session-Id']\n    })\n);\n\n// Store transports by session ID\nconst transports: Record<string, StreamableHTTPServerTransport | SSEServerTransport> = {};\n\n//=============================================================================\n// STREAMABLE HTTP TRANSPORT (PROTOCOL VERSION 2025-03-26)\n//=============================================================================\n\n// Handle all MCP Streamable HTTP requests (GET, POST, DELETE) on a single endpoint\napp.all('/mcp', async (req: Request, res: Response) => {\n    console.log(`Received ${req.method} request to /mcp`);\n\n    try {\n        // Check for existing session ID\n        const sessionId = req.headers['mcp-session-id'] as string | undefined;\n        let transport: StreamableHTTPServerTransport;\n\n        if (sessionId && transports[sessionId]) {\n            // Check if the transport is of the correct type\n            const existingTransport = transports[sessionId];\n            if (existingTransport instanceof StreamableHTTPServerTransport) {\n                // Reuse existing transport\n                transport = existingTransport;\n            } else {\n                // Transport exists but is not a StreamableHTTPServerTransport (could be SSEServerTransport)\n                res.status(400).json({\n                    jsonrpc: '2.0',\n                    error: {\n                        code: -32000,\n                        message: 'Bad Request: Session exists but uses a different transport protocol'\n                    },\n                    id: null\n                });\n                return;\n            }\n        } else if (!sessionId && req.method === 'POST' && isInitializeRequest(req.body)) {\n            const eventStore = new InMemoryEventStore();\n            transport = new StreamableHTTPServerTransport({\n                sessionIdGenerator: () => randomUUID(),\n                eventStore, // Enable resumability\n                onsessioninitialized: sessionId => {\n                    // Store the transport by session ID when session is initialized\n                    console.log(`StreamableHTTP session initialized with ID: ${sessionId}`);\n                    transports[sessionId] = transport;\n                }\n            });\n\n            // Set up onclose handler to clean up transport when closed\n            transport.onclose = () => {\n                const sid = transport.sessionId;\n                if (sid && transports[sid]) {\n                    console.log(`Transport closed for session ${sid}, removing from transports map`);\n                    delete transports[sid];\n                }\n            };\n\n            // Connect the transport to the MCP server\n            const server = getServer();\n            await server.connect(transport);\n        } else {\n            // Invalid request - no session ID or not initialization request\n            res.status(400).json({\n                jsonrpc: '2.0',\n                error: {\n                    code: -32000,\n                    message: 'Bad Request: No valid session ID provided'\n                },\n                id: null\n            });\n            return;\n        }\n\n        // Handle the request with the transport\n        await transport.handleRequest(req, res, req.body);\n    } catch (error) {\n        console.error('Error handling MCP request:', error);\n        if (!res.headersSent) {\n            res.status(500).json({\n                jsonrpc: '2.0',\n                error: {\n                    code: -32603,\n                    message: 'Internal server error'\n                },\n                id: null\n            });\n        }\n    }\n});\n\n//=============================================================================\n// DEPRECATED HTTP+SSE TRANSPORT (PROTOCOL VERSION 2024-11-05)\n//=============================================================================\n\napp.get('/sse', async (req: Request, res: Response) => {\n    console.log('Received GET request to /sse (deprecated SSE transport)');\n    const transport = new SSEServerTransport('/messages', res);\n    transports[transport.sessionId] = transport;\n    res.on('close', () => {\n        delete transports[transport.sessionId];\n    });\n    const server = getServer();\n    await server.connect(transport);\n});\n\napp.post('/messages', async (req: Request, res: Response) => {\n    const sessionId = req.query.sessionId as string;\n    let transport: SSEServerTransport;\n    const existingTransport = transports[sessionId];\n    if (existingTransport instanceof SSEServerTransport) {\n        // Reuse existing transport\n        transport = existingTransport;\n    } else {\n        // Transport exists but is not a SSEServerTransport (could be StreamableHTTPServerTransport)\n        res.status(400).json({\n            jsonrpc: '2.0',\n            error: {\n                code: -32000,\n                message: 'Bad Request: Session exists but uses a different transport protocol'\n            },\n            id: null\n        });\n        return;\n    }\n    if (transport) {\n        await transport.handlePostMessage(req, res, req.body);\n    } else {\n        res.status(400).send('No transport found for sessionId');\n    }\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, error => {\n    if (error) {\n        console.error('Failed to start server:', error);\n        process.exit(1);\n    }\n    console.log(`Backwards compatible MCP server listening on port ${PORT}`);\n    console.log(`\n==============================================\nSUPPORTED TRANSPORT OPTIONS:\n\n1. Streamable Http(Protocol version: 2025-03-26)\n   Endpoint: /mcp\n   Methods: GET, POST, DELETE\n   Usage: \n     - Initialize with POST to /mcp\n     - Establish SSE stream with GET to /mcp\n     - Send requests with POST to /mcp\n     - Terminate session with DELETE to /mcp\n\n2. Http + SSE (Protocol version: 2024-11-05)\n   Endpoints: /sse (GET) and /messages (POST)\n   Usage:\n     - Establish SSE stream with GET to /sse\n     - Send requests with POST to /messages?sessionId=<id>\n==============================================\n`);\n});\n\n// Handle server shutdown\nprocess.on('SIGINT', async () => {\n    console.log('Shutting down server...');\n\n    // Close all active transports to properly clean up resources\n    for (const sessionId in transports) {\n        try {\n            console.log(`Closing transport for session ${sessionId}`);\n            await transports[sessionId].close();\n            delete transports[sessionId];\n        } catch (error) {\n            console.error(`Error closing transport for session ${sessionId}:`, error);\n        }\n    }\n    console.log('Server shutdown complete');\n    process.exit(0);\n});\n"],"names":["sessionId"],"mappings":"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"}