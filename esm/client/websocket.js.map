{"version":3,"file":"websocket.js","sources":["../../../src/client/websocket.ts"],"sourcesContent":["import { Transport } from '../shared/transport.js';\nimport { JSONRPCMessage, JSONRPCMessageSchema } from '../types.js';\n\nconst SUBPROTOCOL = 'mcp';\n\n/**\n * Client transport for WebSocket: this will connect to a server over the WebSocket protocol.\n */\nexport class WebSocketClientTransport implements Transport {\n    private _socket?: WebSocket;\n    private _url: URL;\n\n    onclose?: () => void;\n    onerror?: (error: Error) => void;\n    onmessage?: (message: JSONRPCMessage) => void;\n\n    constructor(url: URL) {\n        this._url = url;\n    }\n\n    start(): Promise<void> {\n        if (this._socket) {\n            throw new Error(\n                'WebSocketClientTransport already started! If using Client class, note that connect() calls start() automatically.'\n            );\n        }\n\n        return new Promise((resolve, reject) => {\n            this._socket = new WebSocket(this._url, SUBPROTOCOL);\n\n            this._socket.onerror = event => {\n                const error = 'error' in event ? (event.error as Error) : new Error(`WebSocket error: ${JSON.stringify(event)}`);\n                reject(error);\n                this.onerror?.(error);\n            };\n\n            this._socket.onopen = () => {\n                resolve();\n            };\n\n            this._socket.onclose = () => {\n                this.onclose?.();\n            };\n\n            this._socket.onmessage = (event: MessageEvent) => {\n                let message: JSONRPCMessage;\n                try {\n                    message = JSONRPCMessageSchema.parse(JSON.parse(event.data));\n                } catch (error) {\n                    this.onerror?.(error as Error);\n                    return;\n                }\n\n                this.onmessage?.(message);\n            };\n        });\n    }\n\n    async close(): Promise<void> {\n        this._socket?.close();\n    }\n\n    send(message: JSONRPCMessage): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this._socket) {\n                reject(new Error('Not connected'));\n                return;\n            }\n\n            this._socket?.send(JSON.stringify(message));\n            resolve();\n        });\n    }\n}\n"],"names":[],"mappings":";AAGA,MAAM,cAAc;AAKb,MAAM,yBAA8C;AAAA,EAQvD,YAAY,KAAU;AAClB,SAAK,OAAO;AAAA,EAChB;AAAA,EAEA,QAAuB;AACnB,QAAI,KAAK,SAAS;AACd,YAAM,IAAI;AAAA,QACN;AAAA,MAAA;AAAA,IAER;AAEA,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACpC,WAAK,UAAU,IAAI,UAAU,KAAK,MAAM,WAAW;AAEnD,WAAK,QAAQ,UAAU,CAAA,UAAS;AAC5B,cAAM,QAAQ,WAAW,QAAS,MAAM,QAAkB,IAAI,MAAM,oBAAoB,KAAK,UAAU,KAAK,CAAC,EAAE;AAC/G,eAAO,KAAK;AACZ,aAAK,UAAU,KAAK;AAAA,MACxB;AAEA,WAAK,QAAQ,SAAS,MAAM;AACxB,gBAAA;AAAA,MACJ;AAEA,WAAK,QAAQ,UAAU,MAAM;AACzB,aAAK,UAAA;AAAA,MACT;AAEA,WAAK,QAAQ,YAAY,CAAC,UAAwB;AAC9C,YAAI;AACJ,YAAI;AACA,oBAAU,qBAAqB,MAAM,KAAK,MAAM,MAAM,IAAI,CAAC;AAAA,QAC/D,SAAS,OAAO;AACZ,eAAK,UAAU,KAAc;AAC7B;AAAA,QACJ;AAEA,aAAK,YAAY,OAAO;AAAA,MAC5B;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,QAAuB;AACzB,SAAK,SAAS,MAAA;AAAA,EAClB;AAAA,EAEA,KAAK,SAAwC;AACzC,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACpC,UAAI,CAAC,KAAK,SAAS;AACf,eAAO,IAAI,MAAM,eAAe,CAAC;AACjC;AAAA,MACJ;AAEA,WAAK,SAAS,KAAK,KAAK,UAAU,OAAO,CAAC;AAC1C,cAAA;AAAA,IACJ,CAAC;AAAA,EACL;AACJ;"}