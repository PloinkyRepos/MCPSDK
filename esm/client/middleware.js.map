{"version":3,"file":"middleware.js","sources":["../../../src/client/middleware.ts"],"sourcesContent":["import { auth, extractResourceMetadataUrl, OAuthClientProvider, UnauthorizedError } from './auth.js';\nimport { FetchLike } from '../shared/transport.js';\n\n/**\n * Middleware function that wraps and enhances fetch functionality.\n * Takes a fetch handler and returns an enhanced fetch handler.\n */\nexport type Middleware = (next: FetchLike) => FetchLike;\n\n/**\n * Creates a fetch wrapper that handles OAuth authentication automatically.\n *\n * This wrapper will:\n * - Add Authorization headers with access tokens\n * - Handle 401 responses by attempting re-authentication\n * - Retry the original request after successful auth\n * - Handle OAuth errors appropriately (InvalidClientError, etc.)\n *\n * The baseUrl parameter is optional and defaults to using the domain from the request URL.\n * However, you should explicitly provide baseUrl when:\n * - Making requests to multiple subdomains (e.g., api.example.com, cdn.example.com)\n * - Using API paths that differ from OAuth discovery paths (e.g., requesting /api/v1/data but OAuth is at /)\n * - The OAuth server is on a different domain than your API requests\n * - You want to ensure consistent OAuth behavior regardless of request URLs\n *\n * For MCP transports, set baseUrl to the same URL you pass to the transport constructor.\n *\n * Note: This wrapper is designed for general-purpose fetch operations.\n * MCP transports (SSE and StreamableHTTP) already have built-in OAuth handling\n * and should not need this wrapper.\n *\n * @param provider - OAuth client provider for authentication\n * @param baseUrl - Base URL for OAuth server discovery (defaults to request URL domain)\n * @returns A fetch middleware function\n */\nexport const withOAuth =\n    (provider: OAuthClientProvider, baseUrl?: string | URL): Middleware =>\n    next => {\n        return async (input, init) => {\n            const makeRequest = async (): Promise<Response> => {\n                const headers = new Headers(init?.headers);\n\n                // Add authorization header if tokens are available\n                const tokens = await provider.tokens();\n                if (tokens) {\n                    headers.set('Authorization', `Bearer ${tokens.access_token}`);\n                }\n\n                return await next(input, { ...init, headers });\n            };\n\n            let response = await makeRequest();\n\n            // Handle 401 responses by attempting re-authentication\n            if (response.status === 401) {\n                try {\n                    const resourceMetadataUrl = extractResourceMetadataUrl(response);\n\n                    // Use provided baseUrl or extract from request URL\n                    const serverUrl = baseUrl || (typeof input === 'string' ? new URL(input).origin : input.origin);\n\n                    const result = await auth(provider, {\n                        serverUrl,\n                        resourceMetadataUrl,\n                        fetchFn: next\n                    });\n\n                    if (result === 'REDIRECT') {\n                        throw new UnauthorizedError('Authentication requires user authorization - redirect initiated');\n                    }\n\n                    if (result !== 'AUTHORIZED') {\n                        throw new UnauthorizedError(`Authentication failed with result: ${result}`);\n                    }\n\n                    // Retry the request with fresh tokens\n                    response = await makeRequest();\n                } catch (error) {\n                    if (error instanceof UnauthorizedError) {\n                        throw error;\n                    }\n                    throw new UnauthorizedError(`Failed to re-authenticate: ${error instanceof Error ? error.message : String(error)}`);\n                }\n            }\n\n            // If we still have a 401 after re-auth attempt, throw an error\n            if (response.status === 401) {\n                const url = typeof input === 'string' ? input : input.toString();\n                throw new UnauthorizedError(`Authentication failed for ${url}`);\n            }\n\n            return response;\n        };\n    };\n\n/**\n * Logger function type for HTTP requests\n */\nexport type RequestLogger = (input: {\n    method: string;\n    url: string | URL;\n    status: number;\n    statusText: string;\n    duration: number;\n    requestHeaders?: Headers;\n    responseHeaders?: Headers;\n    error?: Error;\n}) => void;\n\n/**\n * Configuration options for the logging middleware\n */\nexport type LoggingOptions = {\n    /**\n     * Custom logger function, defaults to console logging\n     */\n    logger?: RequestLogger;\n\n    /**\n     * Whether to include request headers in logs\n     * @default false\n     */\n    includeRequestHeaders?: boolean;\n\n    /**\n     * Whether to include response headers in logs\n     * @default false\n     */\n    includeResponseHeaders?: boolean;\n\n    /**\n     * Status level filter - only log requests with status >= this value\n     * Set to 0 to log all requests, 400 to log only errors\n     * @default 0\n     */\n    statusLevel?: number;\n};\n\n/**\n * Creates a fetch middleware that logs HTTP requests and responses.\n *\n * When called without arguments `withLogging()`, it uses the default logger that:\n * - Logs successful requests (2xx) to `console.log`\n * - Logs error responses (4xx/5xx) and network errors to `console.error`\n * - Logs all requests regardless of status (statusLevel: 0)\n * - Does not include request or response headers in logs\n * - Measures and displays request duration in milliseconds\n *\n * Important: the default logger uses both `console.log` and `console.error` so it should not be used with\n * `stdio` transports and applications.\n *\n * @param options - Logging configuration options\n * @returns A fetch middleware function\n */\nexport const withLogging = (options: LoggingOptions = {}): Middleware => {\n    const { logger, includeRequestHeaders = false, includeResponseHeaders = false, statusLevel = 0 } = options;\n\n    const defaultLogger: RequestLogger = input => {\n        const { method, url, status, statusText, duration, requestHeaders, responseHeaders, error } = input;\n\n        let message = error\n            ? `HTTP ${method} ${url} failed: ${error.message} (${duration}ms)`\n            : `HTTP ${method} ${url} ${status} ${statusText} (${duration}ms)`;\n\n        // Add headers to message if requested\n        if (includeRequestHeaders && requestHeaders) {\n            const reqHeaders = Array.from(requestHeaders.entries())\n                .map(([key, value]) => `${key}: ${value}`)\n                .join(', ');\n            message += `\\n  Request Headers: {${reqHeaders}}`;\n        }\n\n        if (includeResponseHeaders && responseHeaders) {\n            const resHeaders = Array.from(responseHeaders.entries())\n                .map(([key, value]) => `${key}: ${value}`)\n                .join(', ');\n            message += `\\n  Response Headers: {${resHeaders}}`;\n        }\n\n        if (error || status >= 400) {\n            // eslint-disable-next-line no-console\n            console.error(message);\n        } else {\n            // eslint-disable-next-line no-console\n            console.log(message);\n        }\n    };\n\n    const logFn = logger || defaultLogger;\n\n    return next => async (input, init) => {\n        const startTime = performance.now();\n        const method = init?.method || 'GET';\n        const url = typeof input === 'string' ? input : input.toString();\n        const requestHeaders = includeRequestHeaders ? new Headers(init?.headers) : undefined;\n\n        try {\n            const response = await next(input, init);\n            const duration = performance.now() - startTime;\n\n            // Only log if status meets the log level threshold\n            if (response.status >= statusLevel) {\n                logFn({\n                    method,\n                    url,\n                    status: response.status,\n                    statusText: response.statusText,\n                    duration,\n                    requestHeaders,\n                    responseHeaders: includeResponseHeaders ? response.headers : undefined\n                });\n            }\n\n            return response;\n        } catch (error) {\n            const duration = performance.now() - startTime;\n\n            // Always log errors regardless of log level\n            logFn({\n                method,\n                url,\n                status: 0,\n                statusText: 'Network Error',\n                duration,\n                requestHeaders,\n                error: error as Error\n            });\n\n            throw error;\n        }\n    };\n};\n\n/**\n * Composes multiple fetch middleware functions into a single middleware pipeline.\n * Middleware are applied in the order they appear, creating a chain of handlers.\n *\n * @example\n * ```typescript\n * // Create a middleware pipeline that handles both OAuth and logging\n * const enhancedFetch = applyMiddlewares(\n *   withOAuth(oauthProvider, 'https://api.example.com'),\n *   withLogging({ statusLevel: 400 })\n * )(fetch);\n *\n * // Use the enhanced fetch - it will handle auth and log errors\n * const response = await enhancedFetch('https://api.example.com/data');\n * ```\n *\n * @param middleware - Array of fetch middleware to compose into a pipeline\n * @returns A single composed middleware function\n */\nexport const applyMiddlewares = (...middleware: Middleware[]): Middleware => {\n    return next => {\n        return middleware.reduce((handler, mw) => mw(handler), next);\n    };\n};\n\n/**\n * Helper function to create custom fetch middleware with cleaner syntax.\n * Provides the next handler and request details as separate parameters for easier access.\n *\n * @example\n * ```typescript\n * // Create custom authentication middleware\n * const customAuthMiddleware = createMiddleware(async (next, input, init) => {\n *   const headers = new Headers(init?.headers);\n *   headers.set('X-Custom-Auth', 'my-token');\n *\n *   const response = await next(input, { ...init, headers });\n *\n *   if (response.status === 401) {\n *     console.log('Authentication failed');\n *   }\n *\n *   return response;\n * });\n *\n * // Create conditional middleware\n * const conditionalMiddleware = createMiddleware(async (next, input, init) => {\n *   const url = typeof input === 'string' ? input : input.toString();\n *\n *   // Only add headers for API routes\n *   if (url.includes('/api/')) {\n *     const headers = new Headers(init?.headers);\n *     headers.set('X-API-Version', 'v2');\n *     return next(input, { ...init, headers });\n *   }\n *\n *   // Pass through for non-API routes\n *   return next(input, init);\n * });\n *\n * // Create caching middleware\n * const cacheMiddleware = createMiddleware(async (next, input, init) => {\n *   const cacheKey = typeof input === 'string' ? input : input.toString();\n *\n *   // Check cache first\n *   const cached = await getFromCache(cacheKey);\n *   if (cached) {\n *     return new Response(cached, { status: 200 });\n *   }\n *\n *   // Make request and cache result\n *   const response = await next(input, init);\n *   if (response.ok) {\n *     await saveToCache(cacheKey, await response.clone().text());\n *   }\n *\n *   return response;\n * });\n * ```\n *\n * @param handler - Function that receives the next handler and request parameters\n * @returns A fetch middleware function\n */\nexport const createMiddleware = (handler: (next: FetchLike, input: string | URL, init?: RequestInit) => Promise<Response>): Middleware => {\n    return next => (input, init) => handler(next, input as string | URL, init);\n};\n"],"names":[],"mappings":"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"}