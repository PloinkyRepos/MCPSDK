{"version":3,"file":"auth.js","sources":["../../../src/client/auth.ts"],"sourcesContent":["import pkceChallenge from 'pkce-challenge';\nimport { LATEST_PROTOCOL_VERSION } from '../types.js';\nimport {\n    OAuthClientMetadata,\n    OAuthClientInformation,\n    OAuthTokens,\n    OAuthMetadata,\n    OAuthClientInformationFull,\n    OAuthProtectedResourceMetadata,\n    OAuthErrorResponseSchema,\n    AuthorizationServerMetadata,\n    OpenIdProviderDiscoveryMetadataSchema\n} from '../shared/auth.js';\nimport {\n    OAuthClientInformationFullSchema,\n    OAuthMetadataSchema,\n    OAuthProtectedResourceMetadataSchema,\n    OAuthTokensSchema\n} from '../shared/auth.js';\nimport { checkResourceAllowed, resourceUrlFromServerUrl } from '../shared/auth-utils.js';\nimport {\n    InvalidClientError,\n    InvalidGrantError,\n    OAUTH_ERRORS,\n    OAuthError,\n    ServerError,\n    UnauthorizedClientError\n} from '../server/auth/errors.js';\nimport { FetchLike } from '../shared/transport.js';\n\n/**\n * Implements an end-to-end OAuth client to be used with one MCP server.\n *\n * This client relies upon a concept of an authorized \"session,\" the exact\n * meaning of which is application-defined. Tokens, authorization codes, and\n * code verifiers should not cross different sessions.\n */\nexport interface OAuthClientProvider {\n    /**\n     * The URL to redirect the user agent to after authorization.\n     */\n    get redirectUrl(): string | URL;\n\n    /**\n     * Metadata about this OAuth client.\n     */\n    get clientMetadata(): OAuthClientMetadata;\n\n    /**\n     * Returns a OAuth2 state parameter.\n     */\n    state?(): string | Promise<string>;\n\n    /**\n     * Loads information about this OAuth client, as registered already with the\n     * server, or returns `undefined` if the client is not registered with the\n     * server.\n     */\n    clientInformation(): OAuthClientInformation | undefined | Promise<OAuthClientInformation | undefined>;\n\n    /**\n     * If implemented, this permits the OAuth client to dynamically register with\n     * the server. Client information saved this way should later be read via\n     * `clientInformation()`.\n     *\n     * This method is not required to be implemented if client information is\n     * statically known (e.g., pre-registered).\n     */\n    saveClientInformation?(clientInformation: OAuthClientInformationFull): void | Promise<void>;\n\n    /**\n     * Loads any existing OAuth tokens for the current session, or returns\n     * `undefined` if there are no saved tokens.\n     */\n    tokens(): OAuthTokens | undefined | Promise<OAuthTokens | undefined>;\n\n    /**\n     * Stores new OAuth tokens for the current session, after a successful\n     * authorization.\n     */\n    saveTokens(tokens: OAuthTokens): void | Promise<void>;\n\n    /**\n     * Invoked to redirect the user agent to the given URL to begin the authorization flow.\n     */\n    redirectToAuthorization(authorizationUrl: URL): void | Promise<void>;\n\n    /**\n     * Saves a PKCE code verifier for the current session, before redirecting to\n     * the authorization flow.\n     */\n    saveCodeVerifier(codeVerifier: string): void | Promise<void>;\n\n    /**\n     * Loads the PKCE code verifier for the current session, necessary to validate\n     * the authorization result.\n     */\n    codeVerifier(): string | Promise<string>;\n\n    /**\n     * Adds custom client authentication to OAuth token requests.\n     *\n     * This optional method allows implementations to customize how client credentials\n     * are included in token exchange and refresh requests. When provided, this method\n     * is called instead of the default authentication logic, giving full control over\n     * the authentication mechanism.\n     *\n     * Common use cases include:\n     * - Supporting authentication methods beyond the standard OAuth 2.0 methods\n     * - Adding custom headers for proprietary authentication schemes\n     * - Implementing client assertion-based authentication (e.g., JWT bearer tokens)\n     *\n     * @param headers - The request headers (can be modified to add authentication)\n     * @param params - The request body parameters (can be modified to add credentials)\n     * @param url - The token endpoint URL being called\n     * @param metadata - Optional OAuth metadata for the server, which may include supported authentication methods\n     */\n    addClientAuthentication?(\n        headers: Headers,\n        params: URLSearchParams,\n        url: string | URL,\n        metadata?: AuthorizationServerMetadata\n    ): void | Promise<void>;\n\n    /**\n     * If defined, overrides the selection and validation of the\n     * RFC 8707 Resource Indicator. If left undefined, default\n     * validation behavior will be used.\n     *\n     * Implementations must verify the returned resource matches the MCP server.\n     */\n    validateResourceURL?(serverUrl: string | URL, resource?: string): Promise<URL | undefined>;\n\n    /**\n     * If implemented, provides a way for the client to invalidate (e.g. delete) the specified\n     * credentials, in the case where the server has indicated that they are no longer valid.\n     * This avoids requiring the user to intervene manually.\n     */\n    invalidateCredentials?(scope: 'all' | 'client' | 'tokens' | 'verifier'): void | Promise<void>;\n}\n\nexport type AuthResult = 'AUTHORIZED' | 'REDIRECT';\n\nexport class UnauthorizedError extends Error {\n    constructor(message?: string) {\n        super(message ?? 'Unauthorized');\n    }\n}\n\ntype ClientAuthMethod = 'client_secret_basic' | 'client_secret_post' | 'none';\n\n/**\n * Determines the best client authentication method to use based on server support and client configuration.\n *\n * Priority order (highest to lowest):\n * 1. client_secret_basic (if client secret is available)\n * 2. client_secret_post (if client secret is available)\n * 3. none (for public clients)\n *\n * @param clientInformation - OAuth client information containing credentials\n * @param supportedMethods - Authentication methods supported by the authorization server\n * @returns The selected authentication method\n */\nfunction selectClientAuthMethod(clientInformation: OAuthClientInformation, supportedMethods: string[]): ClientAuthMethod {\n    const hasClientSecret = clientInformation.client_secret !== undefined;\n\n    // If server doesn't specify supported methods, use RFC 6749 defaults\n    if (supportedMethods.length === 0) {\n        return hasClientSecret ? 'client_secret_post' : 'none';\n    }\n\n    // Try methods in priority order (most secure first)\n    if (hasClientSecret && supportedMethods.includes('client_secret_basic')) {\n        return 'client_secret_basic';\n    }\n\n    if (hasClientSecret && supportedMethods.includes('client_secret_post')) {\n        return 'client_secret_post';\n    }\n\n    if (supportedMethods.includes('none')) {\n        return 'none';\n    }\n\n    // Fallback: use what we have\n    return hasClientSecret ? 'client_secret_post' : 'none';\n}\n\n/**\n * Applies client authentication to the request based on the specified method.\n *\n * Implements OAuth 2.1 client authentication methods:\n * - client_secret_basic: HTTP Basic authentication (RFC 6749 Section 2.3.1)\n * - client_secret_post: Credentials in request body (RFC 6749 Section 2.3.1)\n * - none: Public client authentication (RFC 6749 Section 2.1)\n *\n * @param method - The authentication method to use\n * @param clientInformation - OAuth client information containing credentials\n * @param headers - HTTP headers object to modify\n * @param params - URL search parameters to modify\n * @throws {Error} When required credentials are missing\n */\nfunction applyClientAuthentication(\n    method: ClientAuthMethod,\n    clientInformation: OAuthClientInformation,\n    headers: Headers,\n    params: URLSearchParams\n): void {\n    const { client_id, client_secret } = clientInformation;\n\n    switch (method) {\n        case 'client_secret_basic':\n            applyBasicAuth(client_id, client_secret, headers);\n            return;\n        case 'client_secret_post':\n            applyPostAuth(client_id, client_secret, params);\n            return;\n        case 'none':\n            applyPublicAuth(client_id, params);\n            return;\n        default:\n            throw new Error(`Unsupported client authentication method: ${method}`);\n    }\n}\n\n/**\n * Applies HTTP Basic authentication (RFC 6749 Section 2.3.1)\n */\nfunction applyBasicAuth(clientId: string, clientSecret: string | undefined, headers: Headers): void {\n    if (!clientSecret) {\n        throw new Error('client_secret_basic authentication requires a client_secret');\n    }\n\n    const credentials = btoa(`${clientId}:${clientSecret}`);\n    headers.set('Authorization', `Basic ${credentials}`);\n}\n\n/**\n * Applies POST body authentication (RFC 6749 Section 2.3.1)\n */\nfunction applyPostAuth(clientId: string, clientSecret: string | undefined, params: URLSearchParams): void {\n    params.set('client_id', clientId);\n    if (clientSecret) {\n        params.set('client_secret', clientSecret);\n    }\n}\n\n/**\n * Applies public client authentication (RFC 6749 Section 2.1)\n */\nfunction applyPublicAuth(clientId: string, params: URLSearchParams): void {\n    params.set('client_id', clientId);\n}\n\n/**\n * Parses an OAuth error response from a string or Response object.\n *\n * If the input is a standard OAuth2.0 error response, it will be parsed according to the spec\n * and an instance of the appropriate OAuthError subclass will be returned.\n * If parsing fails, it falls back to a generic ServerError that includes\n * the response status (if available) and original content.\n *\n * @param input - A Response object or string containing the error response\n * @returns A Promise that resolves to an OAuthError instance\n */\nexport async function parseErrorResponse(input: Response | string): Promise<OAuthError> {\n    const statusCode = input instanceof Response ? input.status : undefined;\n    const body = input instanceof Response ? await input.text() : input;\n\n    try {\n        const result = OAuthErrorResponseSchema.parse(JSON.parse(body));\n        const { error, error_description, error_uri } = result;\n        const errorClass = OAUTH_ERRORS[error] || ServerError;\n        return new errorClass(error_description || '', error_uri);\n    } catch (error) {\n        // Not a valid OAuth error response, but try to inform the user of the raw data anyway\n        const errorMessage = `${statusCode ? `HTTP ${statusCode}: ` : ''}Invalid OAuth error response: ${error}. Raw body: ${body}`;\n        return new ServerError(errorMessage);\n    }\n}\n\n/**\n * Orchestrates the full auth flow with a server.\n *\n * This can be used as a single entry point for all authorization functionality,\n * instead of linking together the other lower-level functions in this module.\n */\nexport async function auth(\n    provider: OAuthClientProvider,\n    options: {\n        serverUrl: string | URL;\n        authorizationCode?: string;\n        scope?: string;\n        resourceMetadataUrl?: URL;\n        fetchFn?: FetchLike;\n    }\n): Promise<AuthResult> {\n    try {\n        return await authInternal(provider, options);\n    } catch (error) {\n        // Handle recoverable error types by invalidating credentials and retrying\n        if (error instanceof InvalidClientError || error instanceof UnauthorizedClientError) {\n            await provider.invalidateCredentials?.('all');\n            return await authInternal(provider, options);\n        } else if (error instanceof InvalidGrantError) {\n            await provider.invalidateCredentials?.('tokens');\n            return await authInternal(provider, options);\n        }\n\n        // Throw otherwise\n        throw error;\n    }\n}\n\nasync function authInternal(\n    provider: OAuthClientProvider,\n    {\n        serverUrl,\n        authorizationCode,\n        scope,\n        resourceMetadataUrl,\n        fetchFn\n    }: {\n        serverUrl: string | URL;\n        authorizationCode?: string;\n        scope?: string;\n        resourceMetadataUrl?: URL;\n        fetchFn?: FetchLike;\n    }\n): Promise<AuthResult> {\n    let resourceMetadata: OAuthProtectedResourceMetadata | undefined;\n    let authorizationServerUrl: string | URL | undefined;\n    try {\n        resourceMetadata = await discoverOAuthProtectedResourceMetadata(serverUrl, { resourceMetadataUrl }, fetchFn);\n        if (resourceMetadata.authorization_servers && resourceMetadata.authorization_servers.length > 0) {\n            authorizationServerUrl = resourceMetadata.authorization_servers[0];\n        }\n    } catch {\n        // Ignore errors and fall back to /.well-known/oauth-authorization-server\n    }\n\n    /**\n     * If we don't get a valid authorization server metadata from protected resource metadata,\n     * fallback to the legacy MCP spec's implementation (version 2025-03-26): MCP server acts as the Authorization server.\n     */\n    if (!authorizationServerUrl) {\n        authorizationServerUrl = serverUrl;\n    }\n\n    const resource: URL | undefined = await selectResourceURL(serverUrl, provider, resourceMetadata);\n\n    const metadata = await discoverAuthorizationServerMetadata(authorizationServerUrl, {\n        fetchFn\n    });\n\n    // Handle client registration if needed\n    let clientInformation = await Promise.resolve(provider.clientInformation());\n    if (!clientInformation) {\n        if (authorizationCode !== undefined) {\n            throw new Error('Existing OAuth client information is required when exchanging an authorization code');\n        }\n\n        if (!provider.saveClientInformation) {\n            throw new Error('OAuth client information must be saveable for dynamic registration');\n        }\n\n        const fullInformation = await registerClient(authorizationServerUrl, {\n            metadata,\n            clientMetadata: provider.clientMetadata,\n            fetchFn\n        });\n\n        await provider.saveClientInformation(fullInformation);\n        clientInformation = fullInformation;\n    }\n\n    // Exchange authorization code for tokens\n    if (authorizationCode !== undefined) {\n        const codeVerifier = await provider.codeVerifier();\n        const tokens = await exchangeAuthorization(authorizationServerUrl, {\n            metadata,\n            clientInformation,\n            authorizationCode,\n            codeVerifier,\n            redirectUri: provider.redirectUrl,\n            resource,\n            addClientAuthentication: provider.addClientAuthentication,\n            fetchFn: fetchFn\n        });\n\n        await provider.saveTokens(tokens);\n        return 'AUTHORIZED';\n    }\n\n    const tokens = await provider.tokens();\n\n    // Handle token refresh or new authorization\n    if (tokens?.refresh_token) {\n        try {\n            // Attempt to refresh the token\n            const newTokens = await refreshAuthorization(authorizationServerUrl, {\n                metadata,\n                clientInformation,\n                refreshToken: tokens.refresh_token,\n                resource,\n                addClientAuthentication: provider.addClientAuthentication,\n                fetchFn\n            });\n\n            await provider.saveTokens(newTokens);\n            return 'AUTHORIZED';\n        } catch (error) {\n            // If this is a ServerError, or an unknown type, log it out and try to continue. Otherwise, escalate so we can fix things and retry.\n            if (!(error instanceof OAuthError) || error instanceof ServerError) {\n                // Could not refresh OAuth tokens\n            } else {\n                // Refresh failed for another reason, re-throw\n                throw error;\n            }\n        }\n    }\n\n    const state = provider.state ? await provider.state() : undefined;\n\n    // Start new authorization flow\n    const { authorizationUrl, codeVerifier } = await startAuthorization(authorizationServerUrl, {\n        metadata,\n        clientInformation,\n        state,\n        redirectUrl: provider.redirectUrl,\n        scope: scope || provider.clientMetadata.scope,\n        resource\n    });\n\n    await provider.saveCodeVerifier(codeVerifier);\n    await provider.redirectToAuthorization(authorizationUrl);\n    return 'REDIRECT';\n}\n\nexport async function selectResourceURL(\n    serverUrl: string | URL,\n    provider: OAuthClientProvider,\n    resourceMetadata?: OAuthProtectedResourceMetadata\n): Promise<URL | undefined> {\n    const defaultResource = resourceUrlFromServerUrl(serverUrl);\n\n    // If provider has custom validation, delegate to it\n    if (provider.validateResourceURL) {\n        return await provider.validateResourceURL(defaultResource, resourceMetadata?.resource);\n    }\n\n    // Only include resource parameter when Protected Resource Metadata is present\n    if (!resourceMetadata) {\n        return undefined;\n    }\n\n    // Validate that the metadata's resource is compatible with our request\n    if (!checkResourceAllowed({ requestedResource: defaultResource, configuredResource: resourceMetadata.resource })) {\n        throw new Error(`Protected resource ${resourceMetadata.resource} does not match expected ${defaultResource} (or origin)`);\n    }\n    // Prefer the resource from metadata since it's what the server is telling us to request\n    return new URL(resourceMetadata.resource);\n}\n\n/**\n * Extract resource_metadata from response header.\n */\nexport function extractResourceMetadataUrl(res: Response): URL | undefined {\n    const authenticateHeader = res.headers.get('WWW-Authenticate');\n    if (!authenticateHeader) {\n        return undefined;\n    }\n\n    const [type, scheme] = authenticateHeader.split(' ');\n    if (type.toLowerCase() !== 'bearer' || !scheme) {\n        return undefined;\n    }\n    const regex = /resource_metadata=\"([^\"]*)\"/;\n    const match = regex.exec(authenticateHeader);\n\n    if (!match) {\n        return undefined;\n    }\n\n    try {\n        return new URL(match[1]);\n    } catch {\n        return undefined;\n    }\n}\n\n/**\n * Looks up RFC 9728 OAuth 2.0 Protected Resource Metadata.\n *\n * If the server returns a 404 for the well-known endpoint, this function will\n * return `undefined`. Any other errors will be thrown as exceptions.\n */\nexport async function discoverOAuthProtectedResourceMetadata(\n    serverUrl: string | URL,\n    opts?: { protocolVersion?: string; resourceMetadataUrl?: string | URL },\n    fetchFn: FetchLike = fetch\n): Promise<OAuthProtectedResourceMetadata> {\n    const response = await discoverMetadataWithFallback(serverUrl, 'oauth-protected-resource', fetchFn, {\n        protocolVersion: opts?.protocolVersion,\n        metadataUrl: opts?.resourceMetadataUrl\n    });\n\n    if (!response || response.status === 404) {\n        throw new Error(`Resource server does not implement OAuth 2.0 Protected Resource Metadata.`);\n    }\n\n    if (!response.ok) {\n        throw new Error(`HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`);\n    }\n    return OAuthProtectedResourceMetadataSchema.parse(await response.json());\n}\n\n/**\n * Helper function to handle fetch with CORS retry logic\n */\nasync function fetchWithCorsRetry(url: URL, headers?: Record<string, string>, fetchFn: FetchLike = fetch): Promise<Response | undefined> {\n    try {\n        return await fetchFn(url, { headers });\n    } catch (error) {\n        if (error instanceof TypeError) {\n            if (headers) {\n                // CORS errors come back as TypeError, retry without headers\n                return fetchWithCorsRetry(url, undefined, fetchFn);\n            } else {\n                // We're getting CORS errors on retry too, return undefined\n                return undefined;\n            }\n        }\n        throw error;\n    }\n}\n\n/**\n * Constructs the well-known path for auth-related metadata discovery\n */\nfunction buildWellKnownPath(\n    wellKnownPrefix: 'oauth-authorization-server' | 'oauth-protected-resource' | 'openid-configuration',\n    pathname: string = '',\n    options: { prependPathname?: boolean } = {}\n): string {\n    // Strip trailing slash from pathname to avoid double slashes\n    if (pathname.endsWith('/')) {\n        pathname = pathname.slice(0, -1);\n    }\n\n    return options.prependPathname ? `${pathname}/.well-known/${wellKnownPrefix}` : `/.well-known/${wellKnownPrefix}${pathname}`;\n}\n\n/**\n * Tries to discover OAuth metadata at a specific URL\n */\nasync function tryMetadataDiscovery(url: URL, protocolVersion: string, fetchFn: FetchLike = fetch): Promise<Response | undefined> {\n    const headers = {\n        'MCP-Protocol-Version': protocolVersion\n    };\n    return await fetchWithCorsRetry(url, headers, fetchFn);\n}\n\n/**\n * Determines if fallback to root discovery should be attempted\n */\nfunction shouldAttemptFallback(response: Response | undefined, pathname: string): boolean {\n    return !response || (response.status >= 400 && response.status < 500 && pathname !== '/');\n}\n\n/**\n * Generic function for discovering OAuth metadata with fallback support\n */\nasync function discoverMetadataWithFallback(\n    serverUrl: string | URL,\n    wellKnownType: 'oauth-authorization-server' | 'oauth-protected-resource',\n    fetchFn: FetchLike,\n    opts?: { protocolVersion?: string; metadataUrl?: string | URL; metadataServerUrl?: string | URL }\n): Promise<Response | undefined> {\n    const issuer = new URL(serverUrl);\n    const protocolVersion = opts?.protocolVersion ?? LATEST_PROTOCOL_VERSION;\n\n    let url: URL;\n    if (opts?.metadataUrl) {\n        url = new URL(opts.metadataUrl);\n    } else {\n        // Try path-aware discovery first\n        const wellKnownPath = buildWellKnownPath(wellKnownType, issuer.pathname);\n        url = new URL(wellKnownPath, opts?.metadataServerUrl ?? issuer);\n        url.search = issuer.search;\n    }\n\n    let response = await tryMetadataDiscovery(url, protocolVersion, fetchFn);\n\n    // If path-aware discovery fails with 404 and we're not already at root, try fallback to root discovery\n    if (!opts?.metadataUrl && shouldAttemptFallback(response, issuer.pathname)) {\n        const rootUrl = new URL(`/.well-known/${wellKnownType}`, issuer);\n        response = await tryMetadataDiscovery(rootUrl, protocolVersion, fetchFn);\n    }\n\n    return response;\n}\n\n/**\n * Looks up RFC 8414 OAuth 2.0 Authorization Server Metadata.\n *\n * If the server returns a 404 for the well-known endpoint, this function will\n * return `undefined`. Any other errors will be thrown as exceptions.\n *\n * @deprecated This function is deprecated in favor of `discoverAuthorizationServerMetadata`.\n */\nexport async function discoverOAuthMetadata(\n    issuer: string | URL,\n    {\n        authorizationServerUrl,\n        protocolVersion\n    }: {\n        authorizationServerUrl?: string | URL;\n        protocolVersion?: string;\n    } = {},\n    fetchFn: FetchLike = fetch\n): Promise<OAuthMetadata | undefined> {\n    if (typeof issuer === 'string') {\n        issuer = new URL(issuer);\n    }\n    if (!authorizationServerUrl) {\n        authorizationServerUrl = issuer;\n    }\n    if (typeof authorizationServerUrl === 'string') {\n        authorizationServerUrl = new URL(authorizationServerUrl);\n    }\n    protocolVersion ??= LATEST_PROTOCOL_VERSION;\n\n    const response = await discoverMetadataWithFallback(authorizationServerUrl, 'oauth-authorization-server', fetchFn, {\n        protocolVersion,\n        metadataServerUrl: authorizationServerUrl\n    });\n\n    if (!response || response.status === 404) {\n        return undefined;\n    }\n\n    if (!response.ok) {\n        throw new Error(`HTTP ${response.status} trying to load well-known OAuth metadata`);\n    }\n\n    return OAuthMetadataSchema.parse(await response.json());\n}\n\n/**\n * Builds a list of discovery URLs to try for authorization server metadata.\n * URLs are returned in priority order:\n * 1. OAuth metadata at the given URL\n * 2. OAuth metadata at root (if URL has path)\n * 3. OIDC metadata endpoints\n */\nexport function buildDiscoveryUrls(authorizationServerUrl: string | URL): { url: URL; type: 'oauth' | 'oidc' }[] {\n    const url = typeof authorizationServerUrl === 'string' ? new URL(authorizationServerUrl) : authorizationServerUrl;\n    const hasPath = url.pathname !== '/';\n    const urlsToTry: { url: URL; type: 'oauth' | 'oidc' }[] = [];\n\n    if (!hasPath) {\n        // Root path: https://example.com/.well-known/oauth-authorization-server\n        urlsToTry.push({\n            url: new URL('/.well-known/oauth-authorization-server', url.origin),\n            type: 'oauth'\n        });\n\n        // OIDC: https://example.com/.well-known/openid-configuration\n        urlsToTry.push({\n            url: new URL(`/.well-known/openid-configuration`, url.origin),\n            type: 'oidc'\n        });\n\n        return urlsToTry;\n    }\n\n    // Strip trailing slash from pathname to avoid double slashes\n    let pathname = url.pathname;\n    if (pathname.endsWith('/')) {\n        pathname = pathname.slice(0, -1);\n    }\n\n    // 1. OAuth metadata at the given URL\n    // Insert well-known before the path: https://example.com/.well-known/oauth-authorization-server/tenant1\n    urlsToTry.push({\n        url: new URL(`/.well-known/oauth-authorization-server${pathname}`, url.origin),\n        type: 'oauth'\n    });\n\n    // Root path: https://example.com/.well-known/oauth-authorization-server\n    urlsToTry.push({\n        url: new URL('/.well-known/oauth-authorization-server', url.origin),\n        type: 'oauth'\n    });\n\n    // 3. OIDC metadata endpoints\n    // RFC 8414 style: Insert /.well-known/openid-configuration before the path\n    urlsToTry.push({\n        url: new URL(`/.well-known/openid-configuration${pathname}`, url.origin),\n        type: 'oidc'\n    });\n    // OIDC Discovery 1.0 style: Append /.well-known/openid-configuration after the path\n    urlsToTry.push({\n        url: new URL(`${pathname}/.well-known/openid-configuration`, url.origin),\n        type: 'oidc'\n    });\n\n    return urlsToTry;\n}\n\n/**\n * Discovers authorization server metadata with support for RFC 8414 OAuth 2.0 Authorization Server Metadata\n * and OpenID Connect Discovery 1.0 specifications.\n *\n * This function implements a fallback strategy for authorization server discovery:\n * 1. Attempts RFC 8414 OAuth metadata discovery first\n * 2. If OAuth discovery fails, falls back to OpenID Connect Discovery\n *\n * @param authorizationServerUrl - The authorization server URL obtained from the MCP Server's\n *                                 protected resource metadata, or the MCP server's URL if the\n *                                 metadata was not found.\n * @param options - Configuration options\n * @param options.fetchFn - Optional fetch function for making HTTP requests, defaults to global fetch\n * @param options.protocolVersion - MCP protocol version to use, defaults to LATEST_PROTOCOL_VERSION\n * @returns Promise resolving to authorization server metadata, or undefined if discovery fails\n */\nexport async function discoverAuthorizationServerMetadata(\n    authorizationServerUrl: string | URL,\n    {\n        fetchFn = fetch,\n        protocolVersion = LATEST_PROTOCOL_VERSION\n    }: {\n        fetchFn?: FetchLike;\n        protocolVersion?: string;\n    } = {}\n): Promise<AuthorizationServerMetadata | undefined> {\n    const headers = { 'MCP-Protocol-Version': protocolVersion };\n\n    // Get the list of URLs to try\n    const urlsToTry = buildDiscoveryUrls(authorizationServerUrl);\n\n    // Try each URL in order\n    for (const { url: endpointUrl, type } of urlsToTry) {\n        const response = await fetchWithCorsRetry(endpointUrl, headers, fetchFn);\n\n        if (!response) {\n            /**\n             * CORS error occurred - don't throw as the endpoint may not allow CORS,\n             * continue trying other possible endpoints\n             */\n            continue;\n        }\n\n        if (!response.ok) {\n            // Continue looking for any 4xx response code.\n            if (response.status >= 400 && response.status < 500) {\n                continue; // Try next URL\n            }\n            throw new Error(\n                `HTTP ${response.status} trying to load ${type === 'oauth' ? 'OAuth' : 'OpenID provider'} metadata from ${endpointUrl}`\n            );\n        }\n\n        // Parse and validate based on type\n        if (type === 'oauth') {\n            return OAuthMetadataSchema.parse(await response.json());\n        } else {\n            const metadata = OpenIdProviderDiscoveryMetadataSchema.parse(await response.json());\n\n            // MCP spec requires OIDC providers to support S256 PKCE\n            if (!metadata.code_challenge_methods_supported?.includes('S256')) {\n                throw new Error(\n                    `Incompatible OIDC provider at ${endpointUrl}: does not support S256 code challenge method required by MCP specification`\n                );\n            }\n\n            return metadata;\n        }\n    }\n\n    return undefined;\n}\n\n/**\n * Begins the authorization flow with the given server, by generating a PKCE challenge and constructing the authorization URL.\n */\nexport async function startAuthorization(\n    authorizationServerUrl: string | URL,\n    {\n        metadata,\n        clientInformation,\n        redirectUrl,\n        scope,\n        state,\n        resource\n    }: {\n        metadata?: AuthorizationServerMetadata;\n        clientInformation: OAuthClientInformation;\n        redirectUrl: string | URL;\n        scope?: string;\n        state?: string;\n        resource?: URL;\n    }\n): Promise<{ authorizationUrl: URL; codeVerifier: string }> {\n    const responseType = 'code';\n    const codeChallengeMethod = 'S256';\n\n    let authorizationUrl: URL;\n    if (metadata) {\n        authorizationUrl = new URL(metadata.authorization_endpoint);\n\n        if (!metadata.response_types_supported.includes(responseType)) {\n            throw new Error(`Incompatible auth server: does not support response type ${responseType}`);\n        }\n\n        if (!metadata.code_challenge_methods_supported || !metadata.code_challenge_methods_supported.includes(codeChallengeMethod)) {\n            throw new Error(`Incompatible auth server: does not support code challenge method ${codeChallengeMethod}`);\n        }\n    } else {\n        authorizationUrl = new URL('/authorize', authorizationServerUrl);\n    }\n\n    // Generate PKCE challenge\n    const challenge = await pkceChallenge();\n    const codeVerifier = challenge.code_verifier;\n    const codeChallenge = challenge.code_challenge;\n\n    authorizationUrl.searchParams.set('response_type', responseType);\n    authorizationUrl.searchParams.set('client_id', clientInformation.client_id);\n    authorizationUrl.searchParams.set('code_challenge', codeChallenge);\n    authorizationUrl.searchParams.set('code_challenge_method', codeChallengeMethod);\n    authorizationUrl.searchParams.set('redirect_uri', String(redirectUrl));\n\n    if (state) {\n        authorizationUrl.searchParams.set('state', state);\n    }\n\n    if (scope) {\n        authorizationUrl.searchParams.set('scope', scope);\n    }\n\n    if (scope?.includes('offline_access')) {\n        // if the request includes the OIDC-only \"offline_access\" scope,\n        // we need to set the prompt to \"consent\" to ensure the user is prompted to grant offline access\n        // https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess\n        authorizationUrl.searchParams.append('prompt', 'consent');\n    }\n\n    if (resource) {\n        authorizationUrl.searchParams.set('resource', resource.href);\n    }\n\n    return { authorizationUrl, codeVerifier };\n}\n\n/**\n * Exchanges an authorization code for an access token with the given server.\n *\n * Supports multiple client authentication methods as specified in OAuth 2.1:\n * - Automatically selects the best authentication method based on server support\n * - Falls back to appropriate defaults when server metadata is unavailable\n *\n * @param authorizationServerUrl - The authorization server's base URL\n * @param options - Configuration object containing client info, auth code, etc.\n * @returns Promise resolving to OAuth tokens\n * @throws {Error} When token exchange fails or authentication is invalid\n */\nexport async function exchangeAuthorization(\n    authorizationServerUrl: string | URL,\n    {\n        metadata,\n        clientInformation,\n        authorizationCode,\n        codeVerifier,\n        redirectUri,\n        resource,\n        addClientAuthentication,\n        fetchFn\n    }: {\n        metadata?: AuthorizationServerMetadata;\n        clientInformation: OAuthClientInformation;\n        authorizationCode: string;\n        codeVerifier: string;\n        redirectUri: string | URL;\n        resource?: URL;\n        addClientAuthentication?: OAuthClientProvider['addClientAuthentication'];\n        fetchFn?: FetchLike;\n    }\n): Promise<OAuthTokens> {\n    const grantType = 'authorization_code';\n\n    const tokenUrl = metadata?.token_endpoint ? new URL(metadata.token_endpoint) : new URL('/token', authorizationServerUrl);\n\n    if (metadata?.grant_types_supported && !metadata.grant_types_supported.includes(grantType)) {\n        throw new Error(`Incompatible auth server: does not support grant type ${grantType}`);\n    }\n\n    // Exchange code for tokens\n    const headers = new Headers({\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Accept: 'application/json'\n    });\n    const params = new URLSearchParams({\n        grant_type: grantType,\n        code: authorizationCode,\n        code_verifier: codeVerifier,\n        redirect_uri: String(redirectUri)\n    });\n\n    if (addClientAuthentication) {\n        addClientAuthentication(headers, params, authorizationServerUrl, metadata);\n    } else {\n        // Determine and apply client authentication method\n        const supportedMethods = metadata?.token_endpoint_auth_methods_supported ?? [];\n        const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);\n\n        applyClientAuthentication(authMethod, clientInformation, headers, params);\n    }\n\n    if (resource) {\n        params.set('resource', resource.href);\n    }\n\n    const response = await (fetchFn ?? fetch)(tokenUrl, {\n        method: 'POST',\n        headers,\n        body: params\n    });\n\n    if (!response.ok) {\n        throw await parseErrorResponse(response);\n    }\n\n    return OAuthTokensSchema.parse(await response.json());\n}\n\n/**\n * Exchange a refresh token for an updated access token.\n *\n * Supports multiple client authentication methods as specified in OAuth 2.1:\n * - Automatically selects the best authentication method based on server support\n * - Preserves the original refresh token if a new one is not returned\n *\n * @param authorizationServerUrl - The authorization server's base URL\n * @param options - Configuration object containing client info, refresh token, etc.\n * @returns Promise resolving to OAuth tokens (preserves original refresh_token if not replaced)\n * @throws {Error} When token refresh fails or authentication is invalid\n */\nexport async function refreshAuthorization(\n    authorizationServerUrl: string | URL,\n    {\n        metadata,\n        clientInformation,\n        refreshToken,\n        resource,\n        addClientAuthentication,\n        fetchFn\n    }: {\n        metadata?: AuthorizationServerMetadata;\n        clientInformation: OAuthClientInformation;\n        refreshToken: string;\n        resource?: URL;\n        addClientAuthentication?: OAuthClientProvider['addClientAuthentication'];\n        fetchFn?: FetchLike;\n    }\n): Promise<OAuthTokens> {\n    const grantType = 'refresh_token';\n\n    let tokenUrl: URL;\n    if (metadata) {\n        tokenUrl = new URL(metadata.token_endpoint);\n\n        if (metadata.grant_types_supported && !metadata.grant_types_supported.includes(grantType)) {\n            throw new Error(`Incompatible auth server: does not support grant type ${grantType}`);\n        }\n    } else {\n        tokenUrl = new URL('/token', authorizationServerUrl);\n    }\n\n    // Exchange refresh token\n    const headers = new Headers({\n        'Content-Type': 'application/x-www-form-urlencoded'\n    });\n    const params = new URLSearchParams({\n        grant_type: grantType,\n        refresh_token: refreshToken\n    });\n\n    if (addClientAuthentication) {\n        addClientAuthentication(headers, params, authorizationServerUrl, metadata);\n    } else {\n        // Determine and apply client authentication method\n        const supportedMethods = metadata?.token_endpoint_auth_methods_supported ?? [];\n        const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);\n\n        applyClientAuthentication(authMethod, clientInformation, headers, params);\n    }\n\n    if (resource) {\n        params.set('resource', resource.href);\n    }\n\n    const response = await (fetchFn ?? fetch)(tokenUrl, {\n        method: 'POST',\n        headers,\n        body: params\n    });\n    if (!response.ok) {\n        throw await parseErrorResponse(response);\n    }\n\n    return OAuthTokensSchema.parse({ refresh_token: refreshToken, ...(await response.json()) });\n}\n\n/**\n * Performs OAuth 2.0 Dynamic Client Registration according to RFC 7591.\n */\nexport async function registerClient(\n    authorizationServerUrl: string | URL,\n    {\n        metadata,\n        clientMetadata,\n        fetchFn\n    }: {\n        metadata?: AuthorizationServerMetadata;\n        clientMetadata: OAuthClientMetadata;\n        fetchFn?: FetchLike;\n    }\n): Promise<OAuthClientInformationFull> {\n    let registrationUrl: URL;\n\n    if (metadata) {\n        if (!metadata.registration_endpoint) {\n            throw new Error('Incompatible auth server: does not support dynamic client registration');\n        }\n\n        registrationUrl = new URL(metadata.registration_endpoint);\n    } else {\n        registrationUrl = new URL('/register', authorizationServerUrl);\n    }\n\n    const response = await (fetchFn ?? fetch)(registrationUrl, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(clientMetadata)\n    });\n\n    if (!response.ok) {\n        throw await parseErrorResponse(response);\n    }\n\n    return OAuthClientInformationFullSchema.parse(await response.json());\n}\n"],"names":["codeVerifier","tokens"],"mappings":"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"}