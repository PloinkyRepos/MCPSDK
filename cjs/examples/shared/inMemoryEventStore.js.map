{"version":3,"file":"inMemoryEventStore.js","sources":["../../../../src/examples/shared/inMemoryEventStore.ts"],"sourcesContent":["import { JSONRPCMessage } from '../../types.js';\nimport { EventStore } from '../../server/streamableHttp.js';\n\n/**\n * Simple in-memory implementation of the EventStore interface for resumability\n * This is primarily intended for examples and testing, not for production use\n * where a persistent storage solution would be more appropriate.\n */\nexport class InMemoryEventStore implements EventStore {\n    private events: Map<string, { streamId: string; message: JSONRPCMessage }> = new Map();\n\n    /**\n     * Generates a unique event ID for a given stream ID\n     */\n    private generateEventId(streamId: string): string {\n        return `${streamId}_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;\n    }\n\n    /**\n     * Extracts the stream ID from an event ID\n     */\n    private getStreamIdFromEventId(eventId: string): string {\n        const parts = eventId.split('_');\n        return parts.length > 0 ? parts[0] : '';\n    }\n\n    /**\n     * Stores an event with a generated event ID\n     * Implements EventStore.storeEvent\n     */\n    async storeEvent(streamId: string, message: JSONRPCMessage): Promise<string> {\n        const eventId = this.generateEventId(streamId);\n        this.events.set(eventId, { streamId, message });\n        return eventId;\n    }\n\n    /**\n     * Replays events that occurred after a specific event ID\n     * Implements EventStore.replayEventsAfter\n     */\n    async replayEventsAfter(\n        lastEventId: string,\n        { send }: { send: (eventId: string, message: JSONRPCMessage) => Promise<void> }\n    ): Promise<string> {\n        if (!lastEventId || !this.events.has(lastEventId)) {\n            return '';\n        }\n\n        // Extract the stream ID from the event ID\n        const streamId = this.getStreamIdFromEventId(lastEventId);\n        if (!streamId) {\n            return '';\n        }\n\n        let foundLastEvent = false;\n\n        // Sort events by eventId for chronological ordering\n        const sortedEvents = [...this.events.entries()].sort((a, b) => a[0].localeCompare(b[0]));\n\n        for (const [eventId, { streamId: eventStreamId, message }] of sortedEvents) {\n            // Only include events from the same stream\n            if (eventStreamId !== streamId) {\n                continue;\n            }\n\n            // Start sending events after we find the lastEventId\n            if (eventId === lastEventId) {\n                foundLastEvent = true;\n                continue;\n            }\n\n            if (foundLastEvent) {\n                await send(eventId, message);\n            }\n        }\n        return streamId;\n    }\n}\n"],"names":[],"mappings":";;AAQO,MAAM,mBAAyC;AAAA,EAA/C,cAAA;AACH,SAAQ,6BAAyE,IAAA;AAAA,EAAI;AAAA;AAAA;AAAA;AAAA,EAK7E,gBAAgB,UAA0B;AAC9C,WAAO,GAAG,QAAQ,IAAI,KAAK,IAAA,CAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,UAAU,GAAG,EAAE,CAAC;AAAA,EACnF;AAAA;AAAA;AAAA;AAAA,EAKQ,uBAAuB,SAAyB;AACpD,UAAM,QAAQ,QAAQ,MAAM,GAAG;AAC/B,WAAO,MAAM,SAAS,IAAI,MAAM,CAAC,IAAI;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,WAAW,UAAkB,SAA0C;AACzE,UAAM,UAAU,KAAK,gBAAgB,QAAQ;AAC7C,SAAK,OAAO,IAAI,SAAS,EAAE,UAAU,SAAS;AAC9C,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,kBACF,aACA,EAAE,QACa;AACf,QAAI,CAAC,eAAe,CAAC,KAAK,OAAO,IAAI,WAAW,GAAG;AAC/C,aAAO;AAAA,IACX;AAGA,UAAM,WAAW,KAAK,uBAAuB,WAAW;AACxD,QAAI,CAAC,UAAU;AACX,aAAO;AAAA,IACX;AAEA,QAAI,iBAAiB;AAGrB,UAAM,eAAe,CAAC,GAAG,KAAK,OAAO,QAAA,CAAS,EAAE,KAAK,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,cAAc,EAAE,CAAC,CAAC,CAAC;AAEvF,eAAW,CAAC,SAAS,EAAE,UAAU,eAAe,QAAA,CAAS,KAAK,cAAc;AAExE,UAAI,kBAAkB,UAAU;AAC5B;AAAA,MACJ;AAGA,UAAI,YAAY,aAAa;AACzB,yBAAiB;AACjB;AAAA,MACJ;AAEA,UAAI,gBAAgB;AAChB,cAAM,KAAK,SAAS,OAAO;AAAA,MAC/B;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACJ;;"}