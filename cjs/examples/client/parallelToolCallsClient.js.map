{"version":3,"file":"parallelToolCallsClient.js","sources":["../../../../src/examples/client/parallelToolCallsClient.ts"],"sourcesContent":["import { Client } from '../../client/index.js';\nimport { StreamableHTTPClientTransport } from '../../client/streamableHttp.js';\nimport {\n    ListToolsRequest,\n    ListToolsResultSchema,\n    CallToolResultSchema,\n    LoggingMessageNotificationSchema,\n    CallToolResult\n} from '../../types.js';\n\n/**\n * Parallel Tool Calls MCP Client\n *\n * This client demonstrates how to:\n * 1. Start multiple tool calls in parallel\n * 2. Track notifications from each tool call using a caller parameter\n */\n\n// Command line args processing\nconst args = process.argv.slice(2);\nconst serverUrl = args[0] || 'http://localhost:3000/mcp';\n\nasync function main(): Promise<void> {\n    console.log('MCP Parallel Tool Calls Client');\n    console.log('==============================');\n    console.log(`Connecting to server at: ${serverUrl}`);\n\n    let client: Client;\n    let transport: StreamableHTTPClientTransport;\n\n    try {\n        // Create client with streamable HTTP transport\n        client = new Client({\n            name: 'parallel-tool-calls-client',\n            version: '1.0.0'\n        });\n\n        client.onerror = error => {\n            console.error('Client error:', error);\n        };\n\n        // Connect to the server\n        transport = new StreamableHTTPClientTransport(new URL(serverUrl));\n        await client.connect(transport);\n        console.log('Successfully connected to MCP server');\n\n        // Set up notification handler with caller identification\n        client.setNotificationHandler(LoggingMessageNotificationSchema, notification => {\n            console.log(`Notification: ${notification.params.data}`);\n        });\n\n        console.log('List tools');\n        const toolsRequest = await listTools(client);\n        console.log('Tools: ', toolsRequest);\n\n        // 2. Start multiple notification tools in parallel\n        console.log('\\n=== Starting Multiple Notification Streams in Parallel ===');\n        const toolResults = await startParallelNotificationTools(client);\n\n        // Log the results from each tool call\n        for (const [caller, result] of Object.entries(toolResults)) {\n            console.log(`\\n=== Tool result for ${caller} ===`);\n            result.content.forEach((item: { type: string; text?: string }) => {\n                if (item.type === 'text') {\n                    console.log(`  ${item.text}`);\n                } else {\n                    console.log(`  ${item.type} content:`, item);\n                }\n            });\n        }\n\n        // 3. Wait for all notifications (10 seconds)\n        console.log('\\n=== Waiting for all notifications ===');\n        await new Promise(resolve => setTimeout(resolve, 10000));\n\n        // 4. Disconnect\n        console.log('\\n=== Disconnecting ===');\n        await transport.close();\n        console.log('Disconnected from MCP server');\n    } catch (error) {\n        console.error('Error running client:', error);\n        process.exit(1);\n    }\n}\n\n/**\n * List available tools on the server\n */\nasync function listTools(client: Client): Promise<void> {\n    try {\n        const toolsRequest: ListToolsRequest = {\n            method: 'tools/list',\n            params: {}\n        };\n        const toolsResult = await client.request(toolsRequest, ListToolsResultSchema);\n\n        console.log('Available tools:');\n        if (toolsResult.tools.length === 0) {\n            console.log('  No tools available');\n        } else {\n            for (const tool of toolsResult.tools) {\n                console.log(`  - ${tool.name}: ${tool.description}`);\n            }\n        }\n    } catch (error) {\n        console.log(`Tools not supported by this server: ${error}`);\n    }\n}\n\n/**\n * Start multiple notification tools in parallel with different configurations\n * Each tool call includes a caller parameter to identify its notifications\n */\nasync function startParallelNotificationTools(client: Client): Promise<Record<string, CallToolResult>> {\n    try {\n        // Define multiple tool calls with different configurations\n        const toolCalls = [\n            {\n                caller: 'fast-notifier',\n                request: {\n                    method: 'tools/call',\n                    params: {\n                        name: 'start-notification-stream',\n                        arguments: {\n                            interval: 2, // 0.5 second between notifications\n                            count: 10, // Send 10 notifications\n                            caller: 'fast-notifier' // Identify this tool call\n                        }\n                    }\n                }\n            },\n            {\n                caller: 'slow-notifier',\n                request: {\n                    method: 'tools/call',\n                    params: {\n                        name: 'start-notification-stream',\n                        arguments: {\n                            interval: 5, // 2 seconds between notifications\n                            count: 5, // Send 5 notifications\n                            caller: 'slow-notifier' // Identify this tool call\n                        }\n                    }\n                }\n            },\n            {\n                caller: 'burst-notifier',\n                request: {\n                    method: 'tools/call',\n                    params: {\n                        name: 'start-notification-stream',\n                        arguments: {\n                            interval: 1, // 0.1 second between notifications\n                            count: 3, // Send just 3 notifications\n                            caller: 'burst-notifier' // Identify this tool call\n                        }\n                    }\n                }\n            }\n        ];\n\n        console.log(`Starting ${toolCalls.length} notification tools in parallel...`);\n\n        // Start all tool calls in parallel\n        const toolPromises = toolCalls.map(({ caller, request }) => {\n            console.log(`Starting tool call for ${caller}...`);\n            return client\n                .request(request, CallToolResultSchema)\n                .then(result => ({ caller, result }))\n                .catch(error => {\n                    console.error(`Error in tool call for ${caller}:`, error);\n                    throw error;\n                });\n        });\n\n        // Wait for all tool calls to complete\n        const results = await Promise.all(toolPromises);\n\n        // Organize results by caller\n        const resultsByTool: Record<string, CallToolResult> = {};\n        results.forEach(({ caller, result }) => {\n            resultsByTool[caller] = result;\n        });\n\n        return resultsByTool;\n    } catch (error) {\n        console.error(`Error starting parallel notification tools:`, error);\n        throw error;\n    }\n}\n\n// Start the client\nmain().catch((error: unknown) => {\n    console.error('Error running MCP client:', error);\n    process.exit(1);\n});\n"],"names":["Client","StreamableHTTPClientTransport","LoggingMessageNotificationSchema","ListToolsResultSchema","CallToolResultSchema"],"mappings":";;;;AAmBA,MAAM,OAAO,QAAQ,KAAK,MAAM,CAAC;AACjC,MAAM,YAAY,KAAK,CAAC,KAAK;AAE7B,eAAe,OAAsB;AACjC,UAAQ,IAAI,gCAAgC;AAC5C,UAAQ,IAAI,gCAAgC;AAC5C,UAAQ,IAAI,4BAA4B,SAAS,EAAE;AAEnD,MAAI;AACJ,MAAI;AAEJ,MAAI;AAEA,aAAS,IAAIA,MAAAA,OAAO;AAAA,MAChB,MAAM;AAAA,MACN,SAAS;AAAA,IAAA,CACZ;AAED,WAAO,UAAU,CAAA,UAAS;AACtB,cAAQ,MAAM,iBAAiB,KAAK;AAAA,IACxC;AAGA,gBAAY,IAAIC,eAAAA,8BAA8B,IAAI,IAAI,SAAS,CAAC;AAChE,UAAM,OAAO,QAAQ,SAAS;AAC9B,YAAQ,IAAI,sCAAsC;AAGlD,WAAO,uBAAuBC,wCAAkC,CAAA,iBAAgB;AAC5E,cAAQ,IAAI,iBAAiB,aAAa,OAAO,IAAI,EAAE;AAAA,IAC3D,CAAC;AAED,YAAQ,IAAI,YAAY;AACxB,UAAM,eAAe,MAAM,UAAU,MAAM;AAC3C,YAAQ,IAAI,WAAW,YAAY;AAGnC,YAAQ,IAAI,8DAA8D;AAC1E,UAAM,cAAc,MAAM,+BAA+B,MAAM;AAG/D,eAAW,CAAC,QAAQ,MAAM,KAAK,OAAO,QAAQ,WAAW,GAAG;AACxD,cAAQ,IAAI;AAAA,sBAAyB,MAAM,MAAM;AACjD,aAAO,QAAQ,QAAQ,CAAC,SAA0C;AAC9D,YAAI,KAAK,SAAS,QAAQ;AACtB,kBAAQ,IAAI,KAAK,KAAK,IAAI,EAAE;AAAA,QAChC,OAAO;AACH,kBAAQ,IAAI,KAAK,KAAK,IAAI,aAAa,IAAI;AAAA,QAC/C;AAAA,MACJ,CAAC;AAAA,IACL;AAGA,YAAQ,IAAI,yCAAyC;AACrD,UAAM,IAAI,QAAQ,CAAA,YAAW,WAAW,SAAS,GAAK,CAAC;AAGvD,YAAQ,IAAI,yBAAyB;AACrC,UAAM,UAAU,MAAA;AAChB,YAAQ,IAAI,8BAA8B;AAAA,EAC9C,SAAS,OAAO;AACZ,YAAQ,MAAM,yBAAyB,KAAK;AAC5C,YAAQ,KAAK,CAAC;AAAA,EAClB;AACJ;AAKA,eAAe,UAAU,QAA+B;AACpD,MAAI;AACA,UAAM,eAAiC;AAAA,MACnC,QAAQ;AAAA,MACR,QAAQ,CAAA;AAAA,IAAC;AAEb,UAAM,cAAc,MAAM,OAAO,QAAQ,cAAcC,MAAAA,qBAAqB;AAE5E,YAAQ,IAAI,kBAAkB;AAC9B,QAAI,YAAY,MAAM,WAAW,GAAG;AAChC,cAAQ,IAAI,sBAAsB;AAAA,IACtC,OAAO;AACH,iBAAW,QAAQ,YAAY,OAAO;AAClC,gBAAQ,IAAI,OAAO,KAAK,IAAI,KAAK,KAAK,WAAW,EAAE;AAAA,MACvD;AAAA,IACJ;AAAA,EACJ,SAAS,OAAO;AACZ,YAAQ,IAAI,uCAAuC,KAAK,EAAE;AAAA,EAC9D;AACJ;AAMA,eAAe,+BAA+B,QAAyD;AACnG,MAAI;AAEA,UAAM,YAAY;AAAA,MACd;AAAA,QACI,QAAQ;AAAA,QACR,SAAS;AAAA,UACL,QAAQ;AAAA,UACR,QAAQ;AAAA,YACJ,MAAM;AAAA,YACN,WAAW;AAAA,cACP,UAAU;AAAA;AAAA,cACV,OAAO;AAAA;AAAA,cACP,QAAQ;AAAA;AAAA,YAAA;AAAA,UACZ;AAAA,QACJ;AAAA,MACJ;AAAA,MAEJ;AAAA,QACI,QAAQ;AAAA,QACR,SAAS;AAAA,UACL,QAAQ;AAAA,UACR,QAAQ;AAAA,YACJ,MAAM;AAAA,YACN,WAAW;AAAA,cACP,UAAU;AAAA;AAAA,cACV,OAAO;AAAA;AAAA,cACP,QAAQ;AAAA;AAAA,YAAA;AAAA,UACZ;AAAA,QACJ;AAAA,MACJ;AAAA,MAEJ;AAAA,QACI,QAAQ;AAAA,QACR,SAAS;AAAA,UACL,QAAQ;AAAA,UACR,QAAQ;AAAA,YACJ,MAAM;AAAA,YACN,WAAW;AAAA,cACP,UAAU;AAAA;AAAA,cACV,OAAO;AAAA;AAAA,cACP,QAAQ;AAAA;AAAA,YAAA;AAAA,UACZ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAGJ,YAAQ,IAAI,YAAY,UAAU,MAAM,oCAAoC;AAG5E,UAAM,eAAe,UAAU,IAAI,CAAC,EAAE,QAAQ,cAAc;AACxD,cAAQ,IAAI,0BAA0B,MAAM,KAAK;AACjD,aAAO,OACF,QAAQ,SAASC,MAAAA,oBAAoB,EACrC,KAAK,CAAA,YAAW,EAAE,QAAQ,OAAA,EAAS,EACnC,MAAM,CAAA,UAAS;AACZ,gBAAQ,MAAM,0BAA0B,MAAM,KAAK,KAAK;AACxD,cAAM;AAAA,MACV,CAAC;AAAA,IACT,CAAC;AAGD,UAAM,UAAU,MAAM,QAAQ,IAAI,YAAY;AAG9C,UAAM,gBAAgD,CAAA;AACtD,YAAQ,QAAQ,CAAC,EAAE,QAAQ,aAAa;AACpC,oBAAc,MAAM,IAAI;AAAA,IAC5B,CAAC;AAED,WAAO;AAAA,EACX,SAAS,OAAO;AACZ,YAAQ,MAAM,+CAA+C,KAAK;AAClE,UAAM;AAAA,EACV;AACJ;AAGA,OAAO,MAAM,CAAC,UAAmB;AAC7B,UAAQ,MAAM,6BAA6B,KAAK;AAChD,UAAQ,KAAK,CAAC;AAClB,CAAC;"}