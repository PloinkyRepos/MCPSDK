{"version":3,"file":"streamableHttpWithSseFallbackClient.js","sources":["../../../../src/examples/client/streamableHttpWithSseFallbackClient.ts"],"sourcesContent":["import { Client } from '../../client/index.js';\nimport { StreamableHTTPClientTransport } from '../../client/streamableHttp.js';\nimport { SSEClientTransport } from '../../client/sse.js';\nimport {\n    ListToolsRequest,\n    ListToolsResultSchema,\n    CallToolRequest,\n    CallToolResultSchema,\n    LoggingMessageNotificationSchema\n} from '../../types.js';\n\n/**\n * Simplified Backwards Compatible MCP Client\n *\n * This client demonstrates backward compatibility with both:\n * 1. Modern servers using Streamable HTTP transport (protocol version 2025-03-26)\n * 2. Older servers using HTTP+SSE transport (protocol version 2024-11-05)\n *\n * Following the MCP specification for backwards compatibility:\n * - Attempts to POST an initialize request to the server URL first (modern transport)\n * - If that fails with 4xx status, falls back to GET request for SSE stream (older transport)\n */\n\n// Command line args processing\nconst args = process.argv.slice(2);\nconst serverUrl = args[0] || 'http://localhost:3000/mcp';\n\nasync function main(): Promise<void> {\n    console.log('MCP Backwards Compatible Client');\n    console.log('===============================');\n    console.log(`Connecting to server at: ${serverUrl}`);\n\n    let client: Client;\n    let transport: StreamableHTTPClientTransport | SSEClientTransport;\n\n    try {\n        // Try connecting with automatic transport detection\n        const connection = await connectWithBackwardsCompatibility(serverUrl);\n        client = connection.client;\n        transport = connection.transport;\n\n        // Set up notification handler\n        client.setNotificationHandler(LoggingMessageNotificationSchema, notification => {\n            console.log(`Notification: ${notification.params.level} - ${notification.params.data}`);\n        });\n\n        // DEMO WORKFLOW:\n        // 1. List available tools\n        console.log('\\n=== Listing Available Tools ===');\n        await listTools(client);\n\n        // 2. Call the notification tool\n        console.log('\\n=== Starting Notification Stream ===');\n        await startNotificationTool(client);\n\n        // 3. Wait for all notifications (5 seconds)\n        console.log('\\n=== Waiting for all notifications ===');\n        await new Promise(resolve => setTimeout(resolve, 5000));\n\n        // 4. Disconnect\n        console.log('\\n=== Disconnecting ===');\n        await transport.close();\n        console.log('Disconnected from MCP server');\n    } catch (error) {\n        console.error('Error running client:', error);\n        process.exit(1);\n    }\n}\n\n/**\n * Connect to an MCP server with backwards compatibility\n * Following the spec for client backward compatibility\n */\nasync function connectWithBackwardsCompatibility(url: string): Promise<{\n    client: Client;\n    transport: StreamableHTTPClientTransport | SSEClientTransport;\n    transportType: 'streamable-http' | 'sse';\n}> {\n    console.log('1. Trying Streamable HTTP transport first...');\n\n    // Step 1: Try Streamable HTTP transport first\n    const client = new Client({\n        name: 'backwards-compatible-client',\n        version: '1.0.0'\n    });\n\n    client.onerror = error => {\n        console.error('Client error:', error);\n    };\n    const baseUrl = new URL(url);\n\n    try {\n        // Create modern transport\n        const streamableTransport = new StreamableHTTPClientTransport(baseUrl);\n        await client.connect(streamableTransport);\n\n        console.log('Successfully connected using modern Streamable HTTP transport.');\n        return {\n            client,\n            transport: streamableTransport,\n            transportType: 'streamable-http'\n        };\n    } catch (error) {\n        // Step 2: If transport fails, try the older SSE transport\n        console.log(`StreamableHttp transport connection failed: ${error}`);\n        console.log('2. Falling back to deprecated HTTP+SSE transport...');\n\n        try {\n            // Create SSE transport pointing to /sse endpoint\n            const sseTransport = new SSEClientTransport(baseUrl);\n            const sseClient = new Client({\n                name: 'backwards-compatible-client',\n                version: '1.0.0'\n            });\n            await sseClient.connect(sseTransport);\n\n            console.log('Successfully connected using deprecated HTTP+SSE transport.');\n            return {\n                client: sseClient,\n                transport: sseTransport,\n                transportType: 'sse'\n            };\n        } catch (sseError) {\n            console.error(`Failed to connect with either transport method:\\n1. Streamable HTTP error: ${error}\\n2. SSE error: ${sseError}`);\n            throw new Error('Could not connect to server with any available transport');\n        }\n    }\n}\n\n/**\n * List available tools on the server\n */\nasync function listTools(client: Client): Promise<void> {\n    try {\n        const toolsRequest: ListToolsRequest = {\n            method: 'tools/list',\n            params: {}\n        };\n        const toolsResult = await client.request(toolsRequest, ListToolsResultSchema);\n\n        console.log('Available tools:');\n        if (toolsResult.tools.length === 0) {\n            console.log('  No tools available');\n        } else {\n            for (const tool of toolsResult.tools) {\n                console.log(`  - ${tool.name}: ${tool.description}`);\n            }\n        }\n    } catch (error) {\n        console.log(`Tools not supported by this server: ${error}`);\n    }\n}\n\n/**\n * Start a notification stream by calling the notification tool\n */\nasync function startNotificationTool(client: Client): Promise<void> {\n    try {\n        // Call the notification tool using reasonable defaults\n        const request: CallToolRequest = {\n            method: 'tools/call',\n            params: {\n                name: 'start-notification-stream',\n                arguments: {\n                    interval: 1000, // 1 second between notifications\n                    count: 5 // Send 5 notifications\n                }\n            }\n        };\n\n        console.log('Calling notification tool...');\n        const result = await client.request(request, CallToolResultSchema);\n\n        console.log('Tool result:');\n        result.content.forEach(item => {\n            if (item.type === 'text') {\n                console.log(`  ${item.text}`);\n            } else {\n                console.log(`  ${item.type} content:`, item);\n            }\n        });\n    } catch (error) {\n        console.log(`Error calling notification tool: ${error}`);\n    }\n}\n\n// Start the client\nmain().catch((error: unknown) => {\n    console.error('Error running MCP client:', error);\n    process.exit(1);\n});\n"],"names":["LoggingMessageNotificationSchema","Client","StreamableHTTPClientTransport","SSEClientTransport","ListToolsResultSchema","CallToolResultSchema"],"mappings":"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"}