{"version":3,"file":"jsonResponseStreamableHttp.js","sources":["../../../../src/examples/server/jsonResponseStreamableHttp.ts"],"sourcesContent":["import express, { Request, Response } from 'express';\nimport { randomUUID } from 'node:crypto';\nimport { McpServer } from '../../server/mcp.js';\nimport { StreamableHTTPServerTransport } from '../../server/streamableHttp.js';\nimport { z } from 'zod';\nimport { CallToolResult, isInitializeRequest } from '../../types.js';\nimport cors from 'cors';\n\n// Create an MCP server with implementation details\nconst getServer = () => {\n    const server = new McpServer(\n        {\n            name: 'json-response-streamable-http-server',\n            version: '1.0.0'\n        },\n        {\n            capabilities: {\n                logging: {}\n            }\n        }\n    );\n\n    // Register a simple tool that returns a greeting\n    server.tool(\n        'greet',\n        'A simple greeting tool',\n        {\n            name: z.string().describe('Name to greet')\n        },\n        async ({ name }): Promise<CallToolResult> => {\n            return {\n                content: [\n                    {\n                        type: 'text',\n                        text: `Hello, ${name}!`\n                    }\n                ]\n            };\n        }\n    );\n\n    // Register a tool that sends multiple greetings with notifications\n    server.tool(\n        'multi-greet',\n        'A tool that sends different greetings with delays between them',\n        {\n            name: z.string().describe('Name to greet')\n        },\n        async ({ name }, extra): Promise<CallToolResult> => {\n            const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\n            await server.sendLoggingMessage(\n                {\n                    level: 'debug',\n                    data: `Starting multi-greet for ${name}`\n                },\n                extra.sessionId\n            );\n\n            await sleep(1000); // Wait 1 second before first greeting\n\n            await server.sendLoggingMessage(\n                {\n                    level: 'info',\n                    data: `Sending first greeting to ${name}`\n                },\n                extra.sessionId\n            );\n\n            await sleep(1000); // Wait another second before second greeting\n\n            await server.sendLoggingMessage(\n                {\n                    level: 'info',\n                    data: `Sending second greeting to ${name}`\n                },\n                extra.sessionId\n            );\n\n            return {\n                content: [\n                    {\n                        type: 'text',\n                        text: `Good morning, ${name}!`\n                    }\n                ]\n            };\n        }\n    );\n    return server;\n};\n\nconst app = express();\napp.use(express.json());\n\n// Configure CORS to expose Mcp-Session-Id header for browser-based clients\napp.use(\n    cors({\n        origin: '*', // Allow all origins - adjust as needed for production\n        exposedHeaders: ['Mcp-Session-Id']\n    })\n);\n\n// Map to store transports by session ID\nconst transports: { [sessionId: string]: StreamableHTTPServerTransport } = {};\n\napp.post('/mcp', async (req: Request, res: Response) => {\n    console.log('Received MCP request:', req.body);\n    try {\n        // Check for existing session ID\n        const sessionId = req.headers['mcp-session-id'] as string | undefined;\n        let transport: StreamableHTTPServerTransport;\n\n        if (sessionId && transports[sessionId]) {\n            // Reuse existing transport\n            transport = transports[sessionId];\n        } else if (!sessionId && isInitializeRequest(req.body)) {\n            // New initialization request - use JSON response mode\n            transport = new StreamableHTTPServerTransport({\n                sessionIdGenerator: () => randomUUID(),\n                enableJsonResponse: true, // Enable JSON response mode\n                onsessioninitialized: sessionId => {\n                    // Store the transport by session ID when session is initialized\n                    // This avoids race conditions where requests might come in before the session is stored\n                    console.log(`Session initialized with ID: ${sessionId}`);\n                    transports[sessionId] = transport;\n                }\n            });\n\n            // Connect the transport to the MCP server BEFORE handling the request\n            const server = getServer();\n            await server.connect(transport);\n            await transport.handleRequest(req, res, req.body);\n            return; // Already handled\n        } else {\n            // Invalid request - no session ID or not initialization request\n            res.status(400).json({\n                jsonrpc: '2.0',\n                error: {\n                    code: -32000,\n                    message: 'Bad Request: No valid session ID provided'\n                },\n                id: null\n            });\n            return;\n        }\n\n        // Handle the request with existing transport - no need to reconnect\n        await transport.handleRequest(req, res, req.body);\n    } catch (error) {\n        console.error('Error handling MCP request:', error);\n        if (!res.headersSent) {\n            res.status(500).json({\n                jsonrpc: '2.0',\n                error: {\n                    code: -32603,\n                    message: 'Internal server error'\n                },\n                id: null\n            });\n        }\n    }\n});\n\n// Handle GET requests for SSE streams according to spec\napp.get('/mcp', async (req: Request, res: Response) => {\n    // Since this is a very simple example, we don't support GET requests for this server\n    // The spec requires returning 405 Method Not Allowed in this case\n    res.status(405).set('Allow', 'POST').send('Method Not Allowed');\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, error => {\n    if (error) {\n        console.error('Failed to start server:', error);\n        process.exit(1);\n    }\n    console.log(`MCP Streamable HTTP Server listening on port ${PORT}`);\n});\n\n// Handle server shutdown\nprocess.on('SIGINT', async () => {\n    console.log('Shutting down server...');\n    process.exit(0);\n});\n"],"names":["McpServer","z","isInitializeRequest","StreamableHTTPServerTransport","randomUUID","sessionId"],"mappings":"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"}