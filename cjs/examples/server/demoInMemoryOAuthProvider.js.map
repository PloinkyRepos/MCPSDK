{"version":3,"file":"demoInMemoryOAuthProvider.js","sources":["../../../../src/examples/server/demoInMemoryOAuthProvider.ts"],"sourcesContent":["import { randomUUID } from 'node:crypto';\nimport { AuthorizationParams, OAuthServerProvider } from '../../server/auth/provider.js';\nimport { OAuthRegisteredClientsStore } from '../../server/auth/clients.js';\nimport { OAuthClientInformationFull, OAuthMetadata, OAuthTokens } from '../../shared/auth.js';\nimport express, { Request, Response } from 'express';\nimport { AuthInfo } from '../../server/auth/types.js';\nimport { createOAuthMetadata, mcpAuthRouter } from '../../server/auth/router.js';\nimport { resourceUrlFromServerUrl } from '../../shared/auth-utils.js';\nimport { InvalidRequestError } from '../../server/auth/errors.js';\n\nexport class DemoInMemoryClientsStore implements OAuthRegisteredClientsStore {\n    private clients = new Map<string, OAuthClientInformationFull>();\n\n    async getClient(clientId: string) {\n        return this.clients.get(clientId);\n    }\n\n    async registerClient(clientMetadata: OAuthClientInformationFull) {\n        this.clients.set(clientMetadata.client_id, clientMetadata);\n        return clientMetadata;\n    }\n}\n\n/**\n * ðŸš¨ DEMO ONLY - NOT FOR PRODUCTION\n *\n * This example demonstrates MCP OAuth flow but lacks some of the features required for production use,\n * for example:\n * - Persistent token storage\n * - Rate limiting\n */\nexport class DemoInMemoryAuthProvider implements OAuthServerProvider {\n    clientsStore = new DemoInMemoryClientsStore();\n    private codes = new Map<\n        string,\n        {\n            params: AuthorizationParams;\n            client: OAuthClientInformationFull;\n        }\n    >();\n    private tokens = new Map<string, AuthInfo>();\n\n    constructor(private validateResource?: (resource?: URL) => boolean) {}\n\n    async authorize(client: OAuthClientInformationFull, params: AuthorizationParams, res: Response): Promise<void> {\n        const code = randomUUID();\n\n        const searchParams = new URLSearchParams({\n            code\n        });\n        if (params.state !== undefined) {\n            searchParams.set('state', params.state);\n        }\n\n        this.codes.set(code, {\n            client,\n            params\n        });\n\n        if (!client.redirect_uris.includes(params.redirectUri)) {\n            throw new InvalidRequestError('Unregistered redirect_uri');\n        }\n        const targetUrl = new URL(params.redirectUri);\n        targetUrl.search = searchParams.toString();\n        res.redirect(targetUrl.toString());\n    }\n\n    async challengeForAuthorizationCode(client: OAuthClientInformationFull, authorizationCode: string): Promise<string> {\n        // Store the challenge with the code data\n        const codeData = this.codes.get(authorizationCode);\n        if (!codeData) {\n            throw new Error('Invalid authorization code');\n        }\n\n        return codeData.params.codeChallenge;\n    }\n\n    async exchangeAuthorizationCode(\n        client: OAuthClientInformationFull,\n        authorizationCode: string,\n        // Note: code verifier is checked in token.ts by default\n        // it's unused here for that reason.\n        _codeVerifier?: string\n    ): Promise<OAuthTokens> {\n        const codeData = this.codes.get(authorizationCode);\n        if (!codeData) {\n            throw new Error('Invalid authorization code');\n        }\n\n        if (codeData.client.client_id !== client.client_id) {\n            throw new Error(`Authorization code was not issued to this client, ${codeData.client.client_id} != ${client.client_id}`);\n        }\n\n        if (this.validateResource && !this.validateResource(codeData.params.resource)) {\n            throw new Error(`Invalid resource: ${codeData.params.resource}`);\n        }\n\n        this.codes.delete(authorizationCode);\n        const token = randomUUID();\n\n        const tokenData = {\n            token,\n            clientId: client.client_id,\n            scopes: codeData.params.scopes || [],\n            expiresAt: Date.now() + 3600000, // 1 hour\n            resource: codeData.params.resource,\n            type: 'access'\n        };\n\n        this.tokens.set(token, tokenData);\n\n        return {\n            access_token: token,\n            token_type: 'bearer',\n            expires_in: 3600,\n            scope: (codeData.params.scopes || []).join(' ')\n        };\n    }\n\n    async exchangeRefreshToken(\n        _client: OAuthClientInformationFull,\n        _refreshToken: string,\n        _scopes?: string[],\n        _resource?: URL\n    ): Promise<OAuthTokens> {\n        throw new Error('Not implemented for example demo');\n    }\n\n    async verifyAccessToken(token: string): Promise<AuthInfo> {\n        const tokenData = this.tokens.get(token);\n        if (!tokenData || !tokenData.expiresAt || tokenData.expiresAt < Date.now()) {\n            throw new Error('Invalid or expired token');\n        }\n\n        return {\n            token,\n            clientId: tokenData.clientId,\n            scopes: tokenData.scopes,\n            expiresAt: Math.floor(tokenData.expiresAt / 1000),\n            resource: tokenData.resource\n        };\n    }\n}\n\nexport const setupAuthServer = ({\n    authServerUrl,\n    mcpServerUrl,\n    strictResource\n}: {\n    authServerUrl: URL;\n    mcpServerUrl: URL;\n    strictResource: boolean;\n}): OAuthMetadata => {\n    // Create separate auth server app\n    // NOTE: This is a separate app on a separate port to illustrate\n    // how to separate an OAuth Authorization Server from a Resource\n    // server in the SDK. The SDK is not intended to be provide a standalone\n    // authorization server.\n\n    const validateResource = strictResource\n        ? (resource?: URL) => {\n              if (!resource) return false;\n              const expectedResource = resourceUrlFromServerUrl(mcpServerUrl);\n              return resource.toString() === expectedResource.toString();\n          }\n        : undefined;\n\n    const provider = new DemoInMemoryAuthProvider(validateResource);\n    const authApp = express();\n    authApp.use(express.json());\n    // For introspection requests\n    authApp.use(express.urlencoded());\n\n    // Add OAuth routes to the auth server\n    // NOTE: this will also add a protected resource metadata route,\n    // but it won't be used, so leave it.\n    authApp.use(\n        mcpAuthRouter({\n            provider,\n            issuerUrl: authServerUrl,\n            scopesSupported: ['mcp:tools']\n        })\n    );\n\n    authApp.post('/introspect', async (req: Request, res: Response) => {\n        try {\n            const { token } = req.body;\n            if (!token) {\n                res.status(400).json({ error: 'Token is required' });\n                return;\n            }\n\n            const tokenInfo = await provider.verifyAccessToken(token);\n            res.json({\n                active: true,\n                client_id: tokenInfo.clientId,\n                scope: tokenInfo.scopes.join(' '),\n                exp: tokenInfo.expiresAt,\n                aud: tokenInfo.resource\n            });\n            return;\n        } catch (error) {\n            res.status(401).json({\n                active: false,\n                error: 'Unauthorized',\n                error_description: `Invalid token: ${error}`\n            });\n        }\n    });\n\n    const auth_port = authServerUrl.port;\n    // Start the auth server\n    authApp.listen(auth_port, error => {\n        if (error) {\n            console.error('Failed to start server:', error);\n            process.exit(1);\n        }\n        console.log(`OAuth Authorization Server listening on port ${auth_port}`);\n    });\n\n    // Note: we could fetch this from the server, but then we end up\n    // with some top level async which gets annoying.\n    const oauthMetadata: OAuthMetadata = createOAuthMetadata({\n        provider,\n        issuerUrl: authServerUrl,\n        scopesSupported: ['mcp:tools']\n    });\n\n    oauthMetadata.introspection_endpoint = new URL('/introspect', authServerUrl).href;\n\n    return oauthMetadata;\n};\n"],"names":["randomUUID","InvalidRequestError","resourceUrlFromServerUrl","mcpAuthRouter","createOAuthMetadata"],"mappings":"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"}