{"version":3,"file":"streamableHttp.js","sources":["../../../src/client/streamableHttp.ts"],"sourcesContent":["import { Transport, FetchLike } from '../shared/transport.js';\nimport { isInitializedNotification, isJSONRPCRequest, isJSONRPCResponse, JSONRPCMessage, JSONRPCMessageSchema } from '../types.js';\nimport { auth, AuthResult, extractResourceMetadataUrl, OAuthClientProvider, UnauthorizedError } from './auth.js';\nimport { EventSourceParserStream } from 'eventsource-parser/stream';\n\n// Default reconnection options for StreamableHTTP connections\nconst DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS: StreamableHTTPReconnectionOptions = {\n    initialReconnectionDelay: 1000,\n    maxReconnectionDelay: 30000,\n    reconnectionDelayGrowFactor: 1.5,\n    maxRetries: 2\n};\n\nexport class StreamableHTTPError extends Error {\n    constructor(\n        public readonly code: number | undefined,\n        message: string | undefined\n    ) {\n        super(`Streamable HTTP error: ${message}`);\n    }\n}\n\n/**\n * Options for starting or authenticating an SSE connection\n */\nexport interface StartSSEOptions {\n    /**\n     * The resumption token used to continue long-running requests that were interrupted.\n     *\n     * This allows clients to reconnect and continue from where they left off.\n     */\n    resumptionToken?: string;\n\n    /**\n     * A callback that is invoked when the resumption token changes.\n     *\n     * This allows clients to persist the latest token for potential reconnection.\n     */\n    onresumptiontoken?: (token: string) => void;\n\n    /**\n     * Override Message ID to associate with the replay message\n     * so that response can be associate with the new resumed request.\n     */\n    replayMessageId?: string | number;\n}\n\n/**\n * Configuration options for reconnection behavior of the StreamableHTTPClientTransport.\n */\nexport interface StreamableHTTPReconnectionOptions {\n    /**\n     * Maximum backoff time between reconnection attempts in milliseconds.\n     * Default is 30000 (30 seconds).\n     */\n    maxReconnectionDelay: number;\n\n    /**\n     * Initial backoff time between reconnection attempts in milliseconds.\n     * Default is 1000 (1 second).\n     */\n    initialReconnectionDelay: number;\n\n    /**\n     * The factor by which the reconnection delay increases after each attempt.\n     * Default is 1.5.\n     */\n    reconnectionDelayGrowFactor: number;\n\n    /**\n     * Maximum number of reconnection attempts before giving up.\n     * Default is 2.\n     */\n    maxRetries: number;\n}\n\n/**\n * Configuration options for the `StreamableHTTPClientTransport`.\n */\nexport type StreamableHTTPClientTransportOptions = {\n    /**\n     * An OAuth client provider to use for authentication.\n     *\n     * When an `authProvider` is specified and the connection is started:\n     * 1. The connection is attempted with any existing access token from the `authProvider`.\n     * 2. If the access token has expired, the `authProvider` is used to refresh the token.\n     * 3. If token refresh fails or no access token exists, and auth is required, `OAuthClientProvider.redirectToAuthorization` is called, and an `UnauthorizedError` will be thrown from `connect`/`start`.\n     *\n     * After the user has finished authorizing via their user agent, and is redirected back to the MCP client application, call `StreamableHTTPClientTransport.finishAuth` with the authorization code before retrying the connection.\n     *\n     * If an `authProvider` is not provided, and auth is required, an `UnauthorizedError` will be thrown.\n     *\n     * `UnauthorizedError` might also be thrown when sending any message over the transport, indicating that the session has expired, and needs to be re-authed and reconnected.\n     */\n    authProvider?: OAuthClientProvider;\n\n    /**\n     * Customizes HTTP requests to the server.\n     */\n    requestInit?: RequestInit;\n\n    /**\n     * Custom fetch implementation used for all network requests.\n     */\n    fetch?: FetchLike;\n\n    /**\n     * Options to configure the reconnection behavior.\n     */\n    reconnectionOptions?: StreamableHTTPReconnectionOptions;\n\n    /**\n     * Session ID for the connection. This is used to identify the session on the server.\n     * When not provided and connecting to a server that supports session IDs, the server will generate a new session ID.\n     */\n    sessionId?: string;\n};\n\n/**\n * Client transport for Streamable HTTP: this implements the MCP Streamable HTTP transport specification.\n * It will connect to a server using HTTP POST for sending messages and HTTP GET with Server-Sent Events\n * for receiving messages.\n */\nexport class StreamableHTTPClientTransport implements Transport {\n    private _abortController?: AbortController;\n    private _url: URL;\n    private _resourceMetadataUrl?: URL;\n    private _requestInit?: RequestInit;\n    private _authProvider?: OAuthClientProvider;\n    private _fetch?: FetchLike;\n    private _sessionId?: string;\n    private _reconnectionOptions: StreamableHTTPReconnectionOptions;\n    private _protocolVersion?: string;\n    private _hasCompletedAuthFlow = false; // Circuit breaker: detect auth success followed by immediate 401\n\n    onclose?: () => void;\n    onerror?: (error: Error) => void;\n    onmessage?: (message: JSONRPCMessage) => void;\n\n    constructor(url: URL, opts?: StreamableHTTPClientTransportOptions) {\n        this._url = url;\n        this._resourceMetadataUrl = undefined;\n        this._requestInit = opts?.requestInit;\n        this._authProvider = opts?.authProvider;\n        this._fetch = opts?.fetch;\n        this._sessionId = opts?.sessionId;\n        this._reconnectionOptions = opts?.reconnectionOptions ?? DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS;\n    }\n\n    private async _authThenStart(): Promise<void> {\n        if (!this._authProvider) {\n            throw new UnauthorizedError('No auth provider');\n        }\n\n        let result: AuthResult;\n        try {\n            result = await auth(this._authProvider, {\n                serverUrl: this._url,\n                resourceMetadataUrl: this._resourceMetadataUrl,\n                fetchFn: this._fetch\n            });\n        } catch (error) {\n            this.onerror?.(error as Error);\n            throw error;\n        }\n\n        if (result !== 'AUTHORIZED') {\n            throw new UnauthorizedError();\n        }\n\n        return await this._startOrAuthSse({ resumptionToken: undefined });\n    }\n\n    private async _commonHeaders(): Promise<Headers> {\n        const headers: HeadersInit & Record<string, string> = {};\n        if (this._authProvider) {\n            const tokens = await this._authProvider.tokens();\n            if (tokens) {\n                headers['Authorization'] = `Bearer ${tokens.access_token}`;\n            }\n        }\n\n        if (this._sessionId) {\n            headers['mcp-session-id'] = this._sessionId;\n        }\n        if (this._protocolVersion) {\n            headers['mcp-protocol-version'] = this._protocolVersion;\n        }\n\n        const extraHeaders = this._normalizeHeaders(this._requestInit?.headers);\n\n        return new Headers({\n            ...headers,\n            ...extraHeaders\n        });\n    }\n\n    private async _startOrAuthSse(options: StartSSEOptions): Promise<void> {\n        const { resumptionToken } = options;\n        try {\n            // Try to open an initial SSE stream with GET to listen for server messages\n            // This is optional according to the spec - server may not support it\n            const headers = await this._commonHeaders();\n            headers.set('Accept', 'text/event-stream');\n\n            // Include Last-Event-ID header for resumable streams if provided\n            if (resumptionToken) {\n                headers.set('last-event-id', resumptionToken);\n            }\n\n            const response = await (this._fetch ?? fetch)(this._url, {\n                method: 'GET',\n                headers,\n                signal: this._abortController?.signal\n            });\n\n            if (!response.ok) {\n                if (response.status === 401 && this._authProvider) {\n                    // Need to authenticate\n                    return await this._authThenStart();\n                }\n\n                // 405 indicates that the server does not offer an SSE stream at GET endpoint\n                // This is an expected case that should not trigger an error\n                if (response.status === 405) {\n                    return;\n                }\n\n                throw new StreamableHTTPError(response.status, `Failed to open SSE stream: ${response.statusText}`);\n            }\n\n            this._handleSseStream(response.body, options, true);\n        } catch (error) {\n            this.onerror?.(error as Error);\n            throw error;\n        }\n    }\n\n    /**\n     * Calculates the next reconnection delay using  backoff algorithm\n     *\n     * @param attempt Current reconnection attempt count for the specific stream\n     * @returns Time to wait in milliseconds before next reconnection attempt\n     */\n    private _getNextReconnectionDelay(attempt: number): number {\n        // Access default values directly, ensuring they're never undefined\n        const initialDelay = this._reconnectionOptions.initialReconnectionDelay;\n        const growFactor = this._reconnectionOptions.reconnectionDelayGrowFactor;\n        const maxDelay = this._reconnectionOptions.maxReconnectionDelay;\n\n        // Cap at maximum delay\n        return Math.min(initialDelay * Math.pow(growFactor, attempt), maxDelay);\n    }\n\n    private _normalizeHeaders(headers: HeadersInit | undefined): Record<string, string> {\n        if (!headers) return {};\n\n        if (headers instanceof Headers) {\n            return Object.fromEntries(headers.entries());\n        }\n\n        if (Array.isArray(headers)) {\n            return Object.fromEntries(headers);\n        }\n\n        return { ...(headers as Record<string, string>) };\n    }\n\n    /**\n     * Schedule a reconnection attempt with exponential backoff\n     *\n     * @param lastEventId The ID of the last received event for resumability\n     * @param attemptCount Current reconnection attempt count for this specific stream\n     */\n    private _scheduleReconnection(options: StartSSEOptions, attemptCount = 0): void {\n        // Use provided options or default options\n        const maxRetries = this._reconnectionOptions.maxRetries;\n\n        // Check if we've exceeded maximum retry attempts\n        if (maxRetries > 0 && attemptCount >= maxRetries) {\n            this.onerror?.(new Error(`Maximum reconnection attempts (${maxRetries}) exceeded.`));\n            return;\n        }\n\n        // Calculate next delay based on current attempt count\n        const delay = this._getNextReconnectionDelay(attemptCount);\n\n        // Schedule the reconnection\n        setTimeout(() => {\n            // Use the last event ID to resume where we left off\n            this._startOrAuthSse(options).catch(error => {\n                this.onerror?.(new Error(`Failed to reconnect SSE stream: ${error instanceof Error ? error.message : String(error)}`));\n                // Schedule another attempt if this one failed, incrementing the attempt counter\n                this._scheduleReconnection(options, attemptCount + 1);\n            });\n        }, delay);\n    }\n\n    private _handleSseStream(stream: ReadableStream<Uint8Array> | null, options: StartSSEOptions, isReconnectable: boolean): void {\n        if (!stream) {\n            return;\n        }\n        const { onresumptiontoken, replayMessageId } = options;\n\n        let lastEventId: string | undefined;\n        const processStream = async () => {\n            // this is the closest we can get to trying to catch network errors\n            // if something happens reader will throw\n            try {\n                // Create a pipeline: binary stream -> text decoder -> SSE parser\n                const reader = stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).getReader();\n\n                while (true) {\n                    const { value: event, done } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n\n                    // Update last event ID if provided\n                    if (event.id) {\n                        lastEventId = event.id;\n                        onresumptiontoken?.(event.id);\n                    }\n\n                    if (!event.event || event.event === 'message') {\n                        try {\n                            const message = JSONRPCMessageSchema.parse(JSON.parse(event.data));\n                            if (replayMessageId !== undefined && isJSONRPCResponse(message)) {\n                                message.id = replayMessageId;\n                            }\n                            this.onmessage?.(message);\n                        } catch (error) {\n                            this.onerror?.(error as Error);\n                        }\n                    }\n                }\n            } catch (error) {\n                // Handle stream errors - likely a network disconnect\n                this.onerror?.(new Error(`SSE stream disconnected: ${error}`));\n\n                // Attempt to reconnect if the stream disconnects unexpectedly and we aren't closing\n                if (isReconnectable && this._abortController && !this._abortController.signal.aborted) {\n                    // Use the exponential backoff reconnection strategy\n                    try {\n                        this._scheduleReconnection(\n                            {\n                                resumptionToken: lastEventId,\n                                onresumptiontoken,\n                                replayMessageId\n                            },\n                            0\n                        );\n                    } catch (error) {\n                        this.onerror?.(new Error(`Failed to reconnect: ${error instanceof Error ? error.message : String(error)}`));\n                    }\n                }\n            }\n        };\n        processStream();\n    }\n\n    async start() {\n        if (this._abortController) {\n            throw new Error(\n                'StreamableHTTPClientTransport already started! If using Client class, note that connect() calls start() automatically.'\n            );\n        }\n\n        this._abortController = new AbortController();\n    }\n\n    /**\n     * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.\n     */\n    async finishAuth(authorizationCode: string): Promise<void> {\n        if (!this._authProvider) {\n            throw new UnauthorizedError('No auth provider');\n        }\n\n        const result = await auth(this._authProvider, {\n            serverUrl: this._url,\n            authorizationCode,\n            resourceMetadataUrl: this._resourceMetadataUrl,\n            fetchFn: this._fetch\n        });\n        if (result !== 'AUTHORIZED') {\n            throw new UnauthorizedError('Failed to authorize');\n        }\n    }\n\n    async close(): Promise<void> {\n        // Abort any pending requests\n        this._abortController?.abort();\n\n        this.onclose?.();\n    }\n\n    async send(\n        message: JSONRPCMessage | JSONRPCMessage[],\n        options?: { resumptionToken?: string; onresumptiontoken?: (token: string) => void }\n    ): Promise<void> {\n        try {\n            const { resumptionToken, onresumptiontoken } = options || {};\n\n            if (resumptionToken) {\n                // If we have at last event ID, we need to reconnect the SSE stream\n                this._startOrAuthSse({ resumptionToken, replayMessageId: isJSONRPCRequest(message) ? message.id : undefined }).catch(err =>\n                    this.onerror?.(err)\n                );\n                return;\n            }\n\n            const headers = await this._commonHeaders();\n            headers.set('content-type', 'application/json');\n            headers.set('accept', 'application/json, text/event-stream');\n\n            const init = {\n                ...this._requestInit,\n                method: 'POST',\n                headers,\n                body: JSON.stringify(message),\n                signal: this._abortController?.signal\n            };\n\n            const response = await (this._fetch ?? fetch)(this._url, init);\n\n            // Handle session ID received during initialization\n            const sessionId = response.headers.get('mcp-session-id');\n            if (sessionId) {\n                this._sessionId = sessionId;\n            }\n\n            if (!response.ok) {\n                if (response.status === 401 && this._authProvider) {\n                    // Prevent infinite recursion when server returns 401 after successful auth\n                    if (this._hasCompletedAuthFlow) {\n                        throw new StreamableHTTPError(401, 'Server returned 401 after successful authentication');\n                    }\n\n                    this._resourceMetadataUrl = extractResourceMetadataUrl(response);\n\n                    const result = await auth(this._authProvider, {\n                        serverUrl: this._url,\n                        resourceMetadataUrl: this._resourceMetadataUrl,\n                        fetchFn: this._fetch\n                    });\n                    if (result !== 'AUTHORIZED') {\n                        throw new UnauthorizedError();\n                    }\n\n                    // Mark that we completed auth flow\n                    this._hasCompletedAuthFlow = true;\n                    // Purposely _not_ awaited, so we don't call onerror twice\n                    return this.send(message);\n                }\n\n                const text = await response.text().catch(() => null);\n                throw new Error(`Error POSTing to endpoint (HTTP ${response.status}): ${text}`);\n            }\n\n            // Reset auth loop flag on successful response\n            this._hasCompletedAuthFlow = false;\n\n            // If the response is 202 Accepted, there's no body to process\n            if (response.status === 202) {\n                // if the accepted notification is initialized, we start the SSE stream\n                // if it's supported by the server\n                if (isInitializedNotification(message)) {\n                    // Start without a lastEventId since this is a fresh connection\n                    this._startOrAuthSse({ resumptionToken: undefined }).catch(err => this.onerror?.(err));\n                }\n                return;\n            }\n\n            // Get original message(s) for detecting request IDs\n            const messages = Array.isArray(message) ? message : [message];\n\n            const hasRequests = messages.filter(msg => 'method' in msg && 'id' in msg && msg.id !== undefined).length > 0;\n\n            // Check the response type\n            const contentType = response.headers.get('content-type');\n\n            if (hasRequests) {\n                if (contentType?.includes('text/event-stream')) {\n                    // Handle SSE stream responses for requests\n                    // We use the same handler as standalone streams, which now supports\n                    // reconnection with the last event ID\n                    this._handleSseStream(response.body, { onresumptiontoken }, false);\n                } else if (contentType?.includes('application/json')) {\n                    // For non-streaming servers, we might get direct JSON responses\n                    const data = await response.json();\n                    const responseMessages = Array.isArray(data)\n                        ? data.map(msg => JSONRPCMessageSchema.parse(msg))\n                        : [JSONRPCMessageSchema.parse(data)];\n\n                    for (const msg of responseMessages) {\n                        this.onmessage?.(msg);\n                    }\n                } else {\n                    throw new StreamableHTTPError(-1, `Unexpected content type: ${contentType}`);\n                }\n            }\n        } catch (error) {\n            this.onerror?.(error as Error);\n            throw error;\n        }\n    }\n\n    get sessionId(): string | undefined {\n        return this._sessionId;\n    }\n\n    /**\n     * Terminates the current session by sending a DELETE request to the server.\n     *\n     * Clients that no longer need a particular session\n     * (e.g., because the user is leaving the client application) SHOULD send an\n     * HTTP DELETE to the MCP endpoint with the Mcp-Session-Id header to explicitly\n     * terminate the session.\n     *\n     * The server MAY respond with HTTP 405 Method Not Allowed, indicating that\n     * the server does not allow clients to terminate sessions.\n     */\n    async terminateSession(): Promise<void> {\n        if (!this._sessionId) {\n            return; // No session to terminate\n        }\n\n        try {\n            const headers = await this._commonHeaders();\n\n            const init = {\n                ...this._requestInit,\n                method: 'DELETE',\n                headers,\n                signal: this._abortController?.signal\n            };\n\n            const response = await (this._fetch ?? fetch)(this._url, init);\n\n            // We specifically handle 405 as a valid response according to the spec,\n            // meaning the server does not support explicit session termination\n            if (!response.ok && response.status !== 405) {\n                throw new StreamableHTTPError(response.status, `Failed to terminate session: ${response.statusText}`);\n            }\n\n            this._sessionId = undefined;\n        } catch (error) {\n            this.onerror?.(error as Error);\n            throw error;\n        }\n    }\n\n    setProtocolVersion(version: string): void {\n        this._protocolVersion = version;\n    }\n    get protocolVersion(): string | undefined {\n        return this._protocolVersion;\n    }\n}\n"],"names":["UnauthorizedError","auth","stream","EventSourceParserStream","JSONRPCMessageSchema","isJSONRPCResponse","error","isJSONRPCRequest","extractResourceMetadataUrl","isInitializedNotification"],"mappings":"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"}