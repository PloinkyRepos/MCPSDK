{"version":3,"file":"mcp.js","sources":["../../../src/server/mcp.ts"],"sourcesContent":["import { Server, ServerOptions } from './index.js';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\nimport { z, ZodRawShape, ZodObject, ZodString, AnyZodObject, ZodTypeAny, ZodType, ZodTypeDef, ZodOptional } from 'zod';\nimport {\n    Implementation,\n    Tool,\n    ListToolsResult,\n    CallToolResult,\n    McpError,\n    ErrorCode,\n    CompleteRequest,\n    CompleteResult,\n    PromptReference,\n    ResourceTemplateReference,\n    BaseMetadata,\n    Resource,\n    ListResourcesResult,\n    ListResourceTemplatesRequestSchema,\n    ReadResourceRequestSchema,\n    ListToolsRequestSchema,\n    CallToolRequestSchema,\n    ListResourcesRequestSchema,\n    ListPromptsRequestSchema,\n    GetPromptRequestSchema,\n    CompleteRequestSchema,\n    ListPromptsResult,\n    Prompt,\n    PromptArgument,\n    GetPromptResult,\n    ReadResourceResult,\n    ServerRequest,\n    ServerNotification,\n    ToolAnnotations,\n    LoggingMessageNotification\n} from '../types.js';\nimport { Completable, CompletableDef } from './completable.js';\nimport { UriTemplate, Variables } from '../shared/uriTemplate.js';\nimport { RequestHandlerExtra } from '../shared/protocol.js';\nimport { Transport } from '../shared/transport.js';\n\n/**\n * High-level MCP server that provides a simpler API for working with resources, tools, and prompts.\n * For advanced usage (like sending notifications or setting custom request handlers), use the underlying\n * Server instance available via the `server` property.\n */\nexport class McpServer {\n    /**\n     * The underlying Server instance, useful for advanced operations like sending notifications.\n     */\n    public readonly server: Server;\n\n    private _registeredResources: { [uri: string]: RegisteredResource } = {};\n    private _registeredResourceTemplates: {\n        [name: string]: RegisteredResourceTemplate;\n    } = {};\n    private _registeredTools: { [name: string]: RegisteredTool } = {};\n    private _registeredPrompts: { [name: string]: RegisteredPrompt } = {};\n\n    constructor(serverInfo: Implementation, options?: ServerOptions) {\n        this.server = new Server(serverInfo, options);\n    }\n\n    /**\n     * Attaches to the given transport, starts it, and starts listening for messages.\n     *\n     * The `server` object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.\n     */\n    async connect(transport: Transport): Promise<void> {\n        return await this.server.connect(transport);\n    }\n\n    /**\n     * Closes the connection.\n     */\n    async close(): Promise<void> {\n        await this.server.close();\n    }\n\n    private _toolHandlersInitialized = false;\n\n    private setToolRequestHandlers() {\n        if (this._toolHandlersInitialized) {\n            return;\n        }\n\n        this.server.assertCanSetRequestHandler(ListToolsRequestSchema.shape.method.value);\n        this.server.assertCanSetRequestHandler(CallToolRequestSchema.shape.method.value);\n\n        this.server.registerCapabilities({\n            tools: {\n                listChanged: true\n            }\n        });\n\n        this.server.setRequestHandler(\n            ListToolsRequestSchema,\n            (): ListToolsResult => ({\n                tools: Object.entries(this._registeredTools)\n                    .filter(([, tool]) => tool.enabled)\n                    .map(([name, tool]): Tool => {\n                        const toolDefinition: Tool = {\n                            name,\n                            title: tool.title,\n                            description: tool.description,\n                            inputSchema: tool.inputSchema\n                                ? (zodToJsonSchema(tool.inputSchema, {\n                                      strictUnions: true\n                                  }) as Tool['inputSchema'])\n                                : EMPTY_OBJECT_JSON_SCHEMA,\n                            annotations: tool.annotations,\n                            _meta: tool._meta\n                        };\n\n                        if (tool.outputSchema) {\n                            toolDefinition.outputSchema = zodToJsonSchema(tool.outputSchema, {\n                                strictUnions: true\n                            }) as Tool['outputSchema'];\n                        }\n\n                        return toolDefinition;\n                    })\n            })\n        );\n\n        this.server.setRequestHandler(CallToolRequestSchema, async (request, extra): Promise<CallToolResult> => {\n            const tool = this._registeredTools[request.params.name];\n            if (!tool) {\n                throw new McpError(ErrorCode.InvalidParams, `Tool ${request.params.name} not found`);\n            }\n\n            if (!tool.enabled) {\n                throw new McpError(ErrorCode.InvalidParams, `Tool ${request.params.name} disabled`);\n            }\n\n            let result: CallToolResult;\n\n            if (tool.inputSchema) {\n                const parseResult = await tool.inputSchema.safeParseAsync(request.params.arguments);\n                if (!parseResult.success) {\n                    throw new McpError(\n                        ErrorCode.InvalidParams,\n                        `Invalid arguments for tool ${request.params.name}: ${parseResult.error.message}`\n                    );\n                }\n\n                const args = parseResult.data;\n                const cb = tool.callback as ToolCallback<ZodRawShape>;\n                try {\n                    result = await Promise.resolve(cb(args, extra));\n                } catch (error) {\n                    result = {\n                        content: [\n                            {\n                                type: 'text',\n                                text: error instanceof Error ? error.message : String(error)\n                            }\n                        ],\n                        isError: true\n                    };\n                }\n            } else {\n                const cb = tool.callback as ToolCallback<undefined>;\n                try {\n                    result = await Promise.resolve(cb(extra));\n                } catch (error) {\n                    result = {\n                        content: [\n                            {\n                                type: 'text',\n                                text: error instanceof Error ? error.message : String(error)\n                            }\n                        ],\n                        isError: true\n                    };\n                }\n            }\n\n            if (tool.outputSchema && !result.isError) {\n                if (!result.structuredContent) {\n                    throw new McpError(\n                        ErrorCode.InvalidParams,\n                        `Tool ${request.params.name} has an output schema but no structured content was provided`\n                    );\n                }\n\n                // if the tool has an output schema, validate structured content\n                const parseResult = await tool.outputSchema.safeParseAsync(result.structuredContent);\n                if (!parseResult.success) {\n                    throw new McpError(\n                        ErrorCode.InvalidParams,\n                        `Invalid structured content for tool ${request.params.name}: ${parseResult.error.message}`\n                    );\n                }\n            }\n\n            return result;\n        });\n\n        this._toolHandlersInitialized = true;\n    }\n\n    private _completionHandlerInitialized = false;\n\n    private setCompletionRequestHandler() {\n        if (this._completionHandlerInitialized) {\n            return;\n        }\n\n        this.server.assertCanSetRequestHandler(CompleteRequestSchema.shape.method.value);\n\n        this.server.registerCapabilities({\n            completions: {}\n        });\n\n        this.server.setRequestHandler(CompleteRequestSchema, async (request): Promise<CompleteResult> => {\n            switch (request.params.ref.type) {\n                case 'ref/prompt':\n                    return this.handlePromptCompletion(request, request.params.ref);\n\n                case 'ref/resource':\n                    return this.handleResourceCompletion(request, request.params.ref);\n\n                default:\n                    throw new McpError(ErrorCode.InvalidParams, `Invalid completion reference: ${request.params.ref}`);\n            }\n        });\n\n        this._completionHandlerInitialized = true;\n    }\n\n    private async handlePromptCompletion(request: CompleteRequest, ref: PromptReference): Promise<CompleteResult> {\n        const prompt = this._registeredPrompts[ref.name];\n        if (!prompt) {\n            throw new McpError(ErrorCode.InvalidParams, `Prompt ${ref.name} not found`);\n        }\n\n        if (!prompt.enabled) {\n            throw new McpError(ErrorCode.InvalidParams, `Prompt ${ref.name} disabled`);\n        }\n\n        if (!prompt.argsSchema) {\n            return EMPTY_COMPLETION_RESULT;\n        }\n\n        const field = prompt.argsSchema.shape[request.params.argument.name];\n        if (!(field instanceof Completable)) {\n            return EMPTY_COMPLETION_RESULT;\n        }\n\n        const def: CompletableDef<ZodString> = field._def;\n        const suggestions = await def.complete(request.params.argument.value, request.params.context);\n        return createCompletionResult(suggestions);\n    }\n\n    private async handleResourceCompletion(request: CompleteRequest, ref: ResourceTemplateReference): Promise<CompleteResult> {\n        const template = Object.values(this._registeredResourceTemplates).find(t => t.resourceTemplate.uriTemplate.toString() === ref.uri);\n\n        if (!template) {\n            if (this._registeredResources[ref.uri]) {\n                // Attempting to autocomplete a fixed resource URI is not an error in the spec (but probably should be).\n                return EMPTY_COMPLETION_RESULT;\n            }\n\n            throw new McpError(ErrorCode.InvalidParams, `Resource template ${request.params.ref.uri} not found`);\n        }\n\n        const completer = template.resourceTemplate.completeCallback(request.params.argument.name);\n        if (!completer) {\n            return EMPTY_COMPLETION_RESULT;\n        }\n\n        const suggestions = await completer(request.params.argument.value, request.params.context);\n        return createCompletionResult(suggestions);\n    }\n\n    private _resourceHandlersInitialized = false;\n\n    private setResourceRequestHandlers() {\n        if (this._resourceHandlersInitialized) {\n            return;\n        }\n\n        this.server.assertCanSetRequestHandler(ListResourcesRequestSchema.shape.method.value);\n        this.server.assertCanSetRequestHandler(ListResourceTemplatesRequestSchema.shape.method.value);\n        this.server.assertCanSetRequestHandler(ReadResourceRequestSchema.shape.method.value);\n\n        this.server.registerCapabilities({\n            resources: {\n                listChanged: true\n            }\n        });\n\n        this.server.setRequestHandler(ListResourcesRequestSchema, async (request, extra) => {\n            const resources = Object.entries(this._registeredResources)\n                .filter(([_, resource]) => resource.enabled)\n                .map(([uri, resource]) => ({\n                    uri,\n                    name: resource.name,\n                    ...resource.metadata\n                }));\n\n            const templateResources: Resource[] = [];\n            for (const template of Object.values(this._registeredResourceTemplates)) {\n                if (!template.resourceTemplate.listCallback) {\n                    continue;\n                }\n\n                const result = await template.resourceTemplate.listCallback(extra);\n                for (const resource of result.resources) {\n                    templateResources.push({\n                        ...template.metadata,\n                        // the defined resource metadata should override the template metadata if present\n                        ...resource\n                    });\n                }\n            }\n\n            return { resources: [...resources, ...templateResources] };\n        });\n\n        this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () => {\n            const resourceTemplates = Object.entries(this._registeredResourceTemplates).map(([name, template]) => ({\n                name,\n                uriTemplate: template.resourceTemplate.uriTemplate.toString(),\n                ...template.metadata\n            }));\n\n            return { resourceTemplates };\n        });\n\n        this.server.setRequestHandler(ReadResourceRequestSchema, async (request, extra) => {\n            const uri = new URL(request.params.uri);\n\n            // First check for exact resource match\n            const resource = this._registeredResources[uri.toString()];\n            if (resource) {\n                if (!resource.enabled) {\n                    throw new McpError(ErrorCode.InvalidParams, `Resource ${uri} disabled`);\n                }\n                return resource.readCallback(uri, extra);\n            }\n\n            // Then check templates\n            for (const template of Object.values(this._registeredResourceTemplates)) {\n                const variables = template.resourceTemplate.uriTemplate.match(uri.toString());\n                if (variables) {\n                    return template.readCallback(uri, variables, extra);\n                }\n            }\n\n            throw new McpError(ErrorCode.InvalidParams, `Resource ${uri} not found`);\n        });\n\n        this.setCompletionRequestHandler();\n\n        this._resourceHandlersInitialized = true;\n    }\n\n    private _promptHandlersInitialized = false;\n\n    private setPromptRequestHandlers() {\n        if (this._promptHandlersInitialized) {\n            return;\n        }\n\n        this.server.assertCanSetRequestHandler(ListPromptsRequestSchema.shape.method.value);\n        this.server.assertCanSetRequestHandler(GetPromptRequestSchema.shape.method.value);\n\n        this.server.registerCapabilities({\n            prompts: {\n                listChanged: true\n            }\n        });\n\n        this.server.setRequestHandler(\n            ListPromptsRequestSchema,\n            (): ListPromptsResult => ({\n                prompts: Object.entries(this._registeredPrompts)\n                    .filter(([, prompt]) => prompt.enabled)\n                    .map(([name, prompt]): Prompt => {\n                        return {\n                            name,\n                            title: prompt.title,\n                            description: prompt.description,\n                            arguments: prompt.argsSchema ? promptArgumentsFromSchema(prompt.argsSchema) : undefined\n                        };\n                    })\n            })\n        );\n\n        this.server.setRequestHandler(GetPromptRequestSchema, async (request, extra): Promise<GetPromptResult> => {\n            const prompt = this._registeredPrompts[request.params.name];\n            if (!prompt) {\n                throw new McpError(ErrorCode.InvalidParams, `Prompt ${request.params.name} not found`);\n            }\n\n            if (!prompt.enabled) {\n                throw new McpError(ErrorCode.InvalidParams, `Prompt ${request.params.name} disabled`);\n            }\n\n            if (prompt.argsSchema) {\n                const parseResult = await prompt.argsSchema.safeParseAsync(request.params.arguments);\n                if (!parseResult.success) {\n                    throw new McpError(\n                        ErrorCode.InvalidParams,\n                        `Invalid arguments for prompt ${request.params.name}: ${parseResult.error.message}`\n                    );\n                }\n\n                const args = parseResult.data;\n                const cb = prompt.callback as PromptCallback<PromptArgsRawShape>;\n                return await Promise.resolve(cb(args, extra));\n            } else {\n                const cb = prompt.callback as PromptCallback<undefined>;\n                return await Promise.resolve(cb(extra));\n            }\n        });\n\n        this.setCompletionRequestHandler();\n\n        this._promptHandlersInitialized = true;\n    }\n\n    /**\n     * Registers a resource `name` at a fixed URI, which will use the given callback to respond to read requests.\n     */\n    resource(name: string, uri: string, readCallback: ReadResourceCallback): RegisteredResource;\n\n    /**\n     * Registers a resource `name` at a fixed URI with metadata, which will use the given callback to respond to read requests.\n     */\n    resource(name: string, uri: string, metadata: ResourceMetadata, readCallback: ReadResourceCallback): RegisteredResource;\n\n    /**\n     * Registers a resource `name` with a template pattern, which will use the given callback to respond to read requests.\n     */\n    resource(name: string, template: ResourceTemplate, readCallback: ReadResourceTemplateCallback): RegisteredResourceTemplate;\n\n    /**\n     * Registers a resource `name` with a template pattern and metadata, which will use the given callback to respond to read requests.\n     */\n    resource(\n        name: string,\n        template: ResourceTemplate,\n        metadata: ResourceMetadata,\n        readCallback: ReadResourceTemplateCallback\n    ): RegisteredResourceTemplate;\n\n    resource(name: string, uriOrTemplate: string | ResourceTemplate, ...rest: unknown[]): RegisteredResource | RegisteredResourceTemplate {\n        let metadata: ResourceMetadata | undefined;\n        if (typeof rest[0] === 'object') {\n            metadata = rest.shift() as ResourceMetadata;\n        }\n\n        const readCallback = rest[0] as ReadResourceCallback | ReadResourceTemplateCallback;\n\n        if (typeof uriOrTemplate === 'string') {\n            if (this._registeredResources[uriOrTemplate]) {\n                throw new Error(`Resource ${uriOrTemplate} is already registered`);\n            }\n\n            const registeredResource = this._createRegisteredResource(\n                name,\n                undefined,\n                uriOrTemplate,\n                metadata,\n                readCallback as ReadResourceCallback\n            );\n\n            this.setResourceRequestHandlers();\n            this.sendResourceListChanged();\n            return registeredResource;\n        } else {\n            if (this._registeredResourceTemplates[name]) {\n                throw new Error(`Resource template ${name} is already registered`);\n            }\n\n            const registeredResourceTemplate = this._createRegisteredResourceTemplate(\n                name,\n                undefined,\n                uriOrTemplate,\n                metadata,\n                readCallback as ReadResourceTemplateCallback\n            );\n\n            this.setResourceRequestHandlers();\n            this.sendResourceListChanged();\n            return registeredResourceTemplate;\n        }\n    }\n\n    /**\n     * Registers a resource with a config object and callback.\n     * For static resources, use a URI string. For dynamic resources, use a ResourceTemplate.\n     */\n    registerResource(name: string, uriOrTemplate: string, config: ResourceMetadata, readCallback: ReadResourceCallback): RegisteredResource;\n    registerResource(\n        name: string,\n        uriOrTemplate: ResourceTemplate,\n        config: ResourceMetadata,\n        readCallback: ReadResourceTemplateCallback\n    ): RegisteredResourceTemplate;\n    registerResource(\n        name: string,\n        uriOrTemplate: string | ResourceTemplate,\n        config: ResourceMetadata,\n        readCallback: ReadResourceCallback | ReadResourceTemplateCallback\n    ): RegisteredResource | RegisteredResourceTemplate {\n        if (typeof uriOrTemplate === 'string') {\n            if (this._registeredResources[uriOrTemplate]) {\n                throw new Error(`Resource ${uriOrTemplate} is already registered`);\n            }\n\n            const registeredResource = this._createRegisteredResource(\n                name,\n                (config as BaseMetadata).title,\n                uriOrTemplate,\n                config,\n                readCallback as ReadResourceCallback\n            );\n\n            this.setResourceRequestHandlers();\n            this.sendResourceListChanged();\n            return registeredResource;\n        } else {\n            if (this._registeredResourceTemplates[name]) {\n                throw new Error(`Resource template ${name} is already registered`);\n            }\n\n            const registeredResourceTemplate = this._createRegisteredResourceTemplate(\n                name,\n                (config as BaseMetadata).title,\n                uriOrTemplate,\n                config,\n                readCallback as ReadResourceTemplateCallback\n            );\n\n            this.setResourceRequestHandlers();\n            this.sendResourceListChanged();\n            return registeredResourceTemplate;\n        }\n    }\n\n    private _createRegisteredResource(\n        name: string,\n        title: string | undefined,\n        uri: string,\n        metadata: ResourceMetadata | undefined,\n        readCallback: ReadResourceCallback\n    ): RegisteredResource {\n        const registeredResource: RegisteredResource = {\n            name,\n            title,\n            metadata,\n            readCallback,\n            enabled: true,\n            disable: () => registeredResource.update({ enabled: false }),\n            enable: () => registeredResource.update({ enabled: true }),\n            remove: () => registeredResource.update({ uri: null }),\n            update: updates => {\n                if (typeof updates.uri !== 'undefined' && updates.uri !== uri) {\n                    delete this._registeredResources[uri];\n                    if (updates.uri) this._registeredResources[updates.uri] = registeredResource;\n                }\n                if (typeof updates.name !== 'undefined') registeredResource.name = updates.name;\n                if (typeof updates.title !== 'undefined') registeredResource.title = updates.title;\n                if (typeof updates.metadata !== 'undefined') registeredResource.metadata = updates.metadata;\n                if (typeof updates.callback !== 'undefined') registeredResource.readCallback = updates.callback;\n                if (typeof updates.enabled !== 'undefined') registeredResource.enabled = updates.enabled;\n                this.sendResourceListChanged();\n            }\n        };\n        this._registeredResources[uri] = registeredResource;\n        return registeredResource;\n    }\n\n    private _createRegisteredResourceTemplate(\n        name: string,\n        title: string | undefined,\n        template: ResourceTemplate,\n        metadata: ResourceMetadata | undefined,\n        readCallback: ReadResourceTemplateCallback\n    ): RegisteredResourceTemplate {\n        const registeredResourceTemplate: RegisteredResourceTemplate = {\n            resourceTemplate: template,\n            title,\n            metadata,\n            readCallback,\n            enabled: true,\n            disable: () => registeredResourceTemplate.update({ enabled: false }),\n            enable: () => registeredResourceTemplate.update({ enabled: true }),\n            remove: () => registeredResourceTemplate.update({ name: null }),\n            update: updates => {\n                if (typeof updates.name !== 'undefined' && updates.name !== name) {\n                    delete this._registeredResourceTemplates[name];\n                    if (updates.name) this._registeredResourceTemplates[updates.name] = registeredResourceTemplate;\n                }\n                if (typeof updates.title !== 'undefined') registeredResourceTemplate.title = updates.title;\n                if (typeof updates.template !== 'undefined') registeredResourceTemplate.resourceTemplate = updates.template;\n                if (typeof updates.metadata !== 'undefined') registeredResourceTemplate.metadata = updates.metadata;\n                if (typeof updates.callback !== 'undefined') registeredResourceTemplate.readCallback = updates.callback;\n                if (typeof updates.enabled !== 'undefined') registeredResourceTemplate.enabled = updates.enabled;\n                this.sendResourceListChanged();\n            }\n        };\n        this._registeredResourceTemplates[name] = registeredResourceTemplate;\n        return registeredResourceTemplate;\n    }\n\n    private _createRegisteredPrompt(\n        name: string,\n        title: string | undefined,\n        description: string | undefined,\n        argsSchema: PromptArgsRawShape | undefined,\n        callback: PromptCallback<PromptArgsRawShape | undefined>\n    ): RegisteredPrompt {\n        const registeredPrompt: RegisteredPrompt = {\n            title,\n            description,\n            argsSchema: argsSchema === undefined ? undefined : z.object(argsSchema),\n            callback,\n            enabled: true,\n            disable: () => registeredPrompt.update({ enabled: false }),\n            enable: () => registeredPrompt.update({ enabled: true }),\n            remove: () => registeredPrompt.update({ name: null }),\n            update: updates => {\n                if (typeof updates.name !== 'undefined' && updates.name !== name) {\n                    delete this._registeredPrompts[name];\n                    if (updates.name) this._registeredPrompts[updates.name] = registeredPrompt;\n                }\n                if (typeof updates.title !== 'undefined') registeredPrompt.title = updates.title;\n                if (typeof updates.description !== 'undefined') registeredPrompt.description = updates.description;\n                if (typeof updates.argsSchema !== 'undefined') registeredPrompt.argsSchema = z.object(updates.argsSchema);\n                if (typeof updates.callback !== 'undefined') registeredPrompt.callback = updates.callback;\n                if (typeof updates.enabled !== 'undefined') registeredPrompt.enabled = updates.enabled;\n                this.sendPromptListChanged();\n            }\n        };\n        this._registeredPrompts[name] = registeredPrompt;\n        return registeredPrompt;\n    }\n\n    private _createRegisteredTool(\n        name: string,\n        title: string | undefined,\n        description: string | undefined,\n        inputSchema: ZodRawShape | undefined,\n        outputSchema: ZodRawShape | undefined,\n        annotations: ToolAnnotations | undefined,\n        _meta: Record<string, unknown> | undefined,\n        callback: ToolCallback<ZodRawShape | undefined>\n    ): RegisteredTool {\n        const registeredTool: RegisteredTool = {\n            title,\n            description,\n            inputSchema: inputSchema === undefined ? undefined : z.object(inputSchema),\n            outputSchema: outputSchema === undefined ? undefined : z.object(outputSchema),\n            annotations,\n            _meta,\n            callback,\n            enabled: true,\n            disable: () => registeredTool.update({ enabled: false }),\n            enable: () => registeredTool.update({ enabled: true }),\n            remove: () => registeredTool.update({ name: null }),\n            update: updates => {\n                if (typeof updates.name !== 'undefined' && updates.name !== name) {\n                    delete this._registeredTools[name];\n                    if (updates.name) this._registeredTools[updates.name] = registeredTool;\n                }\n                if (typeof updates.title !== 'undefined') registeredTool.title = updates.title;\n                if (typeof updates.description !== 'undefined') registeredTool.description = updates.description;\n                if (typeof updates.paramsSchema !== 'undefined') registeredTool.inputSchema = z.object(updates.paramsSchema);\n                if (typeof updates.callback !== 'undefined') registeredTool.callback = updates.callback;\n                if (typeof updates.annotations !== 'undefined') registeredTool.annotations = updates.annotations;\n                if (typeof updates._meta !== 'undefined') registeredTool._meta = updates._meta;\n                if (typeof updates.enabled !== 'undefined') registeredTool.enabled = updates.enabled;\n                this.sendToolListChanged();\n            }\n        };\n        this._registeredTools[name] = registeredTool;\n\n        this.setToolRequestHandlers();\n        this.sendToolListChanged();\n\n        return registeredTool;\n    }\n\n    /**\n     * Registers a zero-argument tool `name`, which will run the given function when the client calls it.\n     */\n    tool(name: string, cb: ToolCallback): RegisteredTool;\n\n    /**\n     * Registers a zero-argument tool `name` (with a description) which will run the given function when the client calls it.\n     */\n    tool(name: string, description: string, cb: ToolCallback): RegisteredTool;\n\n    /**\n     * Registers a tool taking either a parameter schema for validation or annotations for additional metadata.\n     * This unified overload handles both `tool(name, paramsSchema, cb)` and `tool(name, annotations, cb)` cases.\n     *\n     * Note: We use a union type for the second parameter because TypeScript cannot reliably disambiguate\n     * between ToolAnnotations and ZodRawShape during overload resolution, as both are plain object types.\n     */\n    tool<Args extends ZodRawShape>(name: string, paramsSchemaOrAnnotations: Args | ToolAnnotations, cb: ToolCallback<Args>): RegisteredTool;\n\n    /**\n     * Registers a tool `name` (with a description) taking either parameter schema or annotations.\n     * This unified overload handles both `tool(name, description, paramsSchema, cb)` and\n     * `tool(name, description, annotations, cb)` cases.\n     *\n     * Note: We use a union type for the third parameter because TypeScript cannot reliably disambiguate\n     * between ToolAnnotations and ZodRawShape during overload resolution, as both are plain object types.\n     */\n    tool<Args extends ZodRawShape>(\n        name: string,\n        description: string,\n        paramsSchemaOrAnnotations: Args | ToolAnnotations,\n        cb: ToolCallback<Args>\n    ): RegisteredTool;\n\n    /**\n     * Registers a tool with both parameter schema and annotations.\n     */\n    tool<Args extends ZodRawShape>(name: string, paramsSchema: Args, annotations: ToolAnnotations, cb: ToolCallback<Args>): RegisteredTool;\n\n    /**\n     * Registers a tool with description, parameter schema, and annotations.\n     */\n    tool<Args extends ZodRawShape>(\n        name: string,\n        description: string,\n        paramsSchema: Args,\n        annotations: ToolAnnotations,\n        cb: ToolCallback<Args>\n    ): RegisteredTool;\n\n    /**\n     * tool() implementation. Parses arguments passed to overrides defined above.\n     */\n    tool(name: string, ...rest: unknown[]): RegisteredTool {\n        if (this._registeredTools[name]) {\n            throw new Error(`Tool ${name} is already registered`);\n        }\n\n        let description: string | undefined;\n        let inputSchema: ZodRawShape | undefined;\n        let outputSchema: ZodRawShape | undefined;\n        let annotations: ToolAnnotations | undefined;\n\n        // Tool properties are passed as separate arguments, with omissions allowed.\n        // Support for this style is frozen as of protocol version 2025-03-26. Future additions\n        // to tool definition should *NOT* be added.\n\n        if (typeof rest[0] === 'string') {\n            description = rest.shift() as string;\n        }\n\n        // Handle the different overload combinations\n        if (rest.length > 1) {\n            // We have at least one more arg before the callback\n            const firstArg = rest[0];\n\n            if (isZodRawShape(firstArg)) {\n                // We have a params schema as the first arg\n                inputSchema = rest.shift() as ZodRawShape;\n\n                // Check if the next arg is potentially annotations\n                if (rest.length > 1 && typeof rest[0] === 'object' && rest[0] !== null && !isZodRawShape(rest[0])) {\n                    // Case: tool(name, paramsSchema, annotations, cb)\n                    // Or: tool(name, description, paramsSchema, annotations, cb)\n                    annotations = rest.shift() as ToolAnnotations;\n                }\n            } else if (typeof firstArg === 'object' && firstArg !== null) {\n                // Not a ZodRawShape, so must be annotations in this position\n                // Case: tool(name, annotations, cb)\n                // Or: tool(name, description, annotations, cb)\n                annotations = rest.shift() as ToolAnnotations;\n            }\n        }\n        const callback = rest[0] as ToolCallback<ZodRawShape | undefined>;\n\n        return this._createRegisteredTool(name, undefined, description, inputSchema, outputSchema, annotations, undefined, callback);\n    }\n\n    /**\n     * Registers a tool with a config object and callback.\n     */\n    registerTool<InputArgs extends ZodRawShape, OutputArgs extends ZodRawShape>(\n        name: string,\n        config: {\n            title?: string;\n            description?: string;\n            inputSchema?: InputArgs;\n            outputSchema?: OutputArgs;\n            annotations?: ToolAnnotations;\n            _meta?: Record<string, unknown>;\n        },\n        cb: ToolCallback<InputArgs>\n    ): RegisteredTool {\n        if (this._registeredTools[name]) {\n            throw new Error(`Tool ${name} is already registered`);\n        }\n\n        const { title, description, inputSchema, outputSchema, annotations, _meta } = config;\n\n        return this._createRegisteredTool(\n            name,\n            title,\n            description,\n            inputSchema,\n            outputSchema,\n            annotations,\n            _meta,\n            cb as ToolCallback<ZodRawShape | undefined>\n        );\n    }\n\n    /**\n     * Registers a zero-argument prompt `name`, which will run the given function when the client calls it.\n     */\n    prompt(name: string, cb: PromptCallback): RegisteredPrompt;\n\n    /**\n     * Registers a zero-argument prompt `name` (with a description) which will run the given function when the client calls it.\n     */\n    prompt(name: string, description: string, cb: PromptCallback): RegisteredPrompt;\n\n    /**\n     * Registers a prompt `name` accepting the given arguments, which must be an object containing named properties associated with Zod schemas. When the client calls it, the function will be run with the parsed and validated arguments.\n     */\n    prompt<Args extends PromptArgsRawShape>(name: string, argsSchema: Args, cb: PromptCallback<Args>): RegisteredPrompt;\n\n    /**\n     * Registers a prompt `name` (with a description) accepting the given arguments, which must be an object containing named properties associated with Zod schemas. When the client calls it, the function will be run with the parsed and validated arguments.\n     */\n    prompt<Args extends PromptArgsRawShape>(\n        name: string,\n        description: string,\n        argsSchema: Args,\n        cb: PromptCallback<Args>\n    ): RegisteredPrompt;\n\n    prompt(name: string, ...rest: unknown[]): RegisteredPrompt {\n        if (this._registeredPrompts[name]) {\n            throw new Error(`Prompt ${name} is already registered`);\n        }\n\n        let description: string | undefined;\n        if (typeof rest[0] === 'string') {\n            description = rest.shift() as string;\n        }\n\n        let argsSchema: PromptArgsRawShape | undefined;\n        if (rest.length > 1) {\n            argsSchema = rest.shift() as PromptArgsRawShape;\n        }\n\n        const cb = rest[0] as PromptCallback<PromptArgsRawShape | undefined>;\n        const registeredPrompt = this._createRegisteredPrompt(name, undefined, description, argsSchema, cb);\n\n        this.setPromptRequestHandlers();\n        this.sendPromptListChanged();\n\n        return registeredPrompt;\n    }\n\n    /**\n     * Registers a prompt with a config object and callback.\n     */\n    registerPrompt<Args extends PromptArgsRawShape>(\n        name: string,\n        config: {\n            title?: string;\n            description?: string;\n            argsSchema?: Args;\n        },\n        cb: PromptCallback<Args>\n    ): RegisteredPrompt {\n        if (this._registeredPrompts[name]) {\n            throw new Error(`Prompt ${name} is already registered`);\n        }\n\n        const { title, description, argsSchema } = config;\n\n        const registeredPrompt = this._createRegisteredPrompt(\n            name,\n            title,\n            description,\n            argsSchema,\n            cb as PromptCallback<PromptArgsRawShape | undefined>\n        );\n\n        this.setPromptRequestHandlers();\n        this.sendPromptListChanged();\n\n        return registeredPrompt;\n    }\n\n    /**\n     * Checks if the server is connected to a transport.\n     * @returns True if the server is connected\n     */\n    isConnected() {\n        return this.server.transport !== undefined;\n    }\n\n    /**\n     * Sends a logging message to the client, if connected.\n     * Note: You only need to send the parameters object, not the entire JSON RPC message\n     * @see LoggingMessageNotification\n     * @param params\n     * @param sessionId optional for stateless and backward compatibility\n     */\n    async sendLoggingMessage(params: LoggingMessageNotification['params'], sessionId?: string) {\n        return this.server.sendLoggingMessage(params, sessionId);\n    }\n    /**\n     * Sends a resource list changed event to the client, if connected.\n     */\n    sendResourceListChanged() {\n        if (this.isConnected()) {\n            this.server.sendResourceListChanged();\n        }\n    }\n\n    /**\n     * Sends a tool list changed event to the client, if connected.\n     */\n    sendToolListChanged() {\n        if (this.isConnected()) {\n            this.server.sendToolListChanged();\n        }\n    }\n\n    /**\n     * Sends a prompt list changed event to the client, if connected.\n     */\n    sendPromptListChanged() {\n        if (this.isConnected()) {\n            this.server.sendPromptListChanged();\n        }\n    }\n}\n\n/**\n * A callback to complete one variable within a resource template's URI template.\n */\nexport type CompleteResourceTemplateCallback = (\n    value: string,\n    context?: {\n        arguments?: Record<string, string>;\n    }\n) => string[] | Promise<string[]>;\n\n/**\n * A resource template combines a URI pattern with optional functionality to enumerate\n * all resources matching that pattern.\n */\nexport class ResourceTemplate {\n    private _uriTemplate: UriTemplate;\n\n    constructor(\n        uriTemplate: string | UriTemplate,\n        private _callbacks: {\n            /**\n             * A callback to list all resources matching this template. This is required to specified, even if `undefined`, to avoid accidentally forgetting resource listing.\n             */\n            list: ListResourcesCallback | undefined;\n\n            /**\n             * An optional callback to autocomplete variables within the URI template. Useful for clients and users to discover possible values.\n             */\n            complete?: {\n                [variable: string]: CompleteResourceTemplateCallback;\n            };\n        }\n    ) {\n        this._uriTemplate = typeof uriTemplate === 'string' ? new UriTemplate(uriTemplate) : uriTemplate;\n    }\n\n    /**\n     * Gets the URI template pattern.\n     */\n    get uriTemplate(): UriTemplate {\n        return this._uriTemplate;\n    }\n\n    /**\n     * Gets the list callback, if one was provided.\n     */\n    get listCallback(): ListResourcesCallback | undefined {\n        return this._callbacks.list;\n    }\n\n    /**\n     * Gets the callback for completing a specific URI template variable, if one was provided.\n     */\n    completeCallback(variable: string): CompleteResourceTemplateCallback | undefined {\n        return this._callbacks.complete?.[variable];\n    }\n}\n\n/**\n * Callback for a tool handler registered with Server.tool().\n *\n * Parameters will include tool arguments, if applicable, as well as other request handler context.\n *\n * The callback should return:\n * - `structuredContent` if the tool has an outputSchema defined\n * - `content` if the tool does not have an outputSchema\n * - Both fields are optional but typically one should be provided\n */\nexport type ToolCallback<Args extends undefined | ZodRawShape = undefined> = Args extends ZodRawShape\n    ? (\n          args: z.objectOutputType<Args, ZodTypeAny>,\n          extra: RequestHandlerExtra<ServerRequest, ServerNotification>\n      ) => CallToolResult | Promise<CallToolResult>\n    : (extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => CallToolResult | Promise<CallToolResult>;\n\nexport type RegisteredTool = {\n    title?: string;\n    description?: string;\n    inputSchema?: AnyZodObject;\n    outputSchema?: AnyZodObject;\n    annotations?: ToolAnnotations;\n    _meta?: Record<string, unknown>;\n    callback: ToolCallback<undefined | ZodRawShape>;\n    enabled: boolean;\n    enable(): void;\n    disable(): void;\n    update<InputArgs extends ZodRawShape, OutputArgs extends ZodRawShape>(updates: {\n        name?: string | null;\n        title?: string;\n        description?: string;\n        paramsSchema?: InputArgs;\n        outputSchema?: OutputArgs;\n        annotations?: ToolAnnotations;\n        _meta?: Record<string, unknown>;\n        callback?: ToolCallback<InputArgs>;\n        enabled?: boolean;\n    }): void;\n    remove(): void;\n};\n\nconst EMPTY_OBJECT_JSON_SCHEMA = {\n    type: 'object' as const,\n    properties: {}\n};\n\n// Helper to check if an object is a Zod schema (ZodRawShape)\nfunction isZodRawShape(obj: unknown): obj is ZodRawShape {\n    if (typeof obj !== 'object' || obj === null) return false;\n\n    const isEmptyObject = Object.keys(obj).length === 0;\n\n    // Check if object is empty or at least one property is a ZodType instance\n    // Note: use heuristic check to avoid instanceof failure across different Zod versions\n    return isEmptyObject || Object.values(obj as object).some(isZodTypeLike);\n}\n\nfunction isZodTypeLike(value: unknown): value is ZodType {\n    return (\n        value !== null &&\n        typeof value === 'object' &&\n        'parse' in value &&\n        typeof value.parse === 'function' &&\n        'safeParse' in value &&\n        typeof value.safeParse === 'function'\n    );\n}\n\n/**\n * Additional, optional information for annotating a resource.\n */\nexport type ResourceMetadata = Omit<Resource, 'uri' | 'name'>;\n\n/**\n * Callback to list all resources matching a given template.\n */\nexport type ListResourcesCallback = (\n    extra: RequestHandlerExtra<ServerRequest, ServerNotification>\n) => ListResourcesResult | Promise<ListResourcesResult>;\n\n/**\n * Callback to read a resource at a given URI.\n */\nexport type ReadResourceCallback = (\n    uri: URL,\n    extra: RequestHandlerExtra<ServerRequest, ServerNotification>\n) => ReadResourceResult | Promise<ReadResourceResult>;\n\nexport type RegisteredResource = {\n    name: string;\n    title?: string;\n    metadata?: ResourceMetadata;\n    readCallback: ReadResourceCallback;\n    enabled: boolean;\n    enable(): void;\n    disable(): void;\n    update(updates: {\n        name?: string;\n        title?: string;\n        uri?: string | null;\n        metadata?: ResourceMetadata;\n        callback?: ReadResourceCallback;\n        enabled?: boolean;\n    }): void;\n    remove(): void;\n};\n\n/**\n * Callback to read a resource at a given URI, following a filled-in URI template.\n */\nexport type ReadResourceTemplateCallback = (\n    uri: URL,\n    variables: Variables,\n    extra: RequestHandlerExtra<ServerRequest, ServerNotification>\n) => ReadResourceResult | Promise<ReadResourceResult>;\n\nexport type RegisteredResourceTemplate = {\n    resourceTemplate: ResourceTemplate;\n    title?: string;\n    metadata?: ResourceMetadata;\n    readCallback: ReadResourceTemplateCallback;\n    enabled: boolean;\n    enable(): void;\n    disable(): void;\n    update(updates: {\n        name?: string | null;\n        title?: string;\n        template?: ResourceTemplate;\n        metadata?: ResourceMetadata;\n        callback?: ReadResourceTemplateCallback;\n        enabled?: boolean;\n    }): void;\n    remove(): void;\n};\n\ntype PromptArgsRawShape = {\n    [k: string]: ZodType<string, ZodTypeDef, string> | ZodOptional<ZodType<string, ZodTypeDef, string>>;\n};\n\nexport type PromptCallback<Args extends undefined | PromptArgsRawShape = undefined> = Args extends PromptArgsRawShape\n    ? (\n          args: z.objectOutputType<Args, ZodTypeAny>,\n          extra: RequestHandlerExtra<ServerRequest, ServerNotification>\n      ) => GetPromptResult | Promise<GetPromptResult>\n    : (extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => GetPromptResult | Promise<GetPromptResult>;\n\nexport type RegisteredPrompt = {\n    title?: string;\n    description?: string;\n    argsSchema?: ZodObject<PromptArgsRawShape>;\n    callback: PromptCallback<undefined | PromptArgsRawShape>;\n    enabled: boolean;\n    enable(): void;\n    disable(): void;\n    update<Args extends PromptArgsRawShape>(updates: {\n        name?: string | null;\n        title?: string;\n        description?: string;\n        argsSchema?: Args;\n        callback?: PromptCallback<Args>;\n        enabled?: boolean;\n    }): void;\n    remove(): void;\n};\n\nfunction promptArgumentsFromSchema(schema: ZodObject<PromptArgsRawShape>): PromptArgument[] {\n    return Object.entries(schema.shape).map(\n        ([name, field]): PromptArgument => ({\n            name,\n            description: field.description,\n            required: !field.isOptional()\n        })\n    );\n}\n\nfunction createCompletionResult(suggestions: string[]): CompleteResult {\n    return {\n        completion: {\n            values: suggestions.slice(0, 100),\n            total: suggestions.length,\n            hasMore: suggestions.length > 100\n        }\n    };\n}\n\nconst EMPTY_COMPLETION_RESULT: CompleteResult = {\n    completion: {\n        values: [],\n        hasMore: false\n    }\n};\n"],"names":["Server","ListToolsRequestSchema","CallToolRequestSchema","zodToJsonSchema","McpError","ErrorCode","CompleteRequestSchema","Completable","ListResourcesRequestSchema","ListResourceTemplatesRequestSchema","ReadResourceRequestSchema","ListPromptsRequestSchema","GetPromptRequestSchema","z","uriTemplate","UriTemplate"],"mappings":"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"}