{"version":3,"file":"inMemory.js","sources":["../../src/inMemory.ts"],"sourcesContent":["import { Transport } from './shared/transport.js';\nimport { JSONRPCMessage, RequestId } from './types.js';\nimport { AuthInfo } from './server/auth/types.js';\n\ninterface QueuedMessage {\n    message: JSONRPCMessage;\n    extra?: { authInfo?: AuthInfo };\n}\n\n/**\n * In-memory transport for creating clients and servers that talk to each other within the same process.\n */\nexport class InMemoryTransport implements Transport {\n    private _otherTransport?: InMemoryTransport;\n    private _messageQueue: QueuedMessage[] = [];\n\n    onclose?: () => void;\n    onerror?: (error: Error) => void;\n    onmessage?: (message: JSONRPCMessage, extra?: { authInfo?: AuthInfo }) => void;\n    sessionId?: string;\n\n    /**\n     * Creates a pair of linked in-memory transports that can communicate with each other. One should be passed to a Client and one to a Server.\n     */\n    static createLinkedPair(): [InMemoryTransport, InMemoryTransport] {\n        const clientTransport = new InMemoryTransport();\n        const serverTransport = new InMemoryTransport();\n        clientTransport._otherTransport = serverTransport;\n        serverTransport._otherTransport = clientTransport;\n        return [clientTransport, serverTransport];\n    }\n\n    async start(): Promise<void> {\n        // Process any messages that were queued before start was called\n        while (this._messageQueue.length > 0) {\n            const queuedMessage = this._messageQueue.shift()!;\n            this.onmessage?.(queuedMessage.message, queuedMessage.extra);\n        }\n    }\n\n    async close(): Promise<void> {\n        const other = this._otherTransport;\n        this._otherTransport = undefined;\n        await other?.close();\n        this.onclose?.();\n    }\n\n    /**\n     * Sends a message with optional auth info.\n     * This is useful for testing authentication scenarios.\n     */\n    async send(message: JSONRPCMessage, options?: { relatedRequestId?: RequestId; authInfo?: AuthInfo }): Promise<void> {\n        if (!this._otherTransport) {\n            throw new Error('Not connected');\n        }\n\n        if (this._otherTransport.onmessage) {\n            this._otherTransport.onmessage(message, { authInfo: options?.authInfo });\n        } else {\n            this._otherTransport._messageQueue.push({ message, extra: { authInfo: options?.authInfo } });\n        }\n    }\n}\n"],"names":[],"mappings":";;AAYO,MAAM,kBAAuC;AAAA,EAA7C,cAAA;AAEH,SAAQ,gBAAiC,CAAA;AAAA,EAAC;AAAA;AAAA;AAAA;AAAA,EAU1C,OAAO,mBAA2D;AAC9D,UAAM,kBAAkB,IAAI,kBAAA;AAC5B,UAAM,kBAAkB,IAAI,kBAAA;AAC5B,oBAAgB,kBAAkB;AAClC,oBAAgB,kBAAkB;AAClC,WAAO,CAAC,iBAAiB,eAAe;AAAA,EAC5C;AAAA,EAEA,MAAM,QAAuB;AAEzB,WAAO,KAAK,cAAc,SAAS,GAAG;AAClC,YAAM,gBAAgB,KAAK,cAAc,MAAA;AACzC,WAAK,YAAY,cAAc,SAAS,cAAc,KAAK;AAAA,IAC/D;AAAA,EACJ;AAAA,EAEA,MAAM,QAAuB;AACzB,UAAM,QAAQ,KAAK;AACnB,SAAK,kBAAkB;AACvB,UAAM,OAAO,MAAA;AACb,SAAK,UAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,KAAK,SAAyB,SAAgF;AAChH,QAAI,CAAC,KAAK,iBAAiB;AACvB,YAAM,IAAI,MAAM,eAAe;AAAA,IACnC;AAEA,QAAI,KAAK,gBAAgB,WAAW;AAChC,WAAK,gBAAgB,UAAU,SAAS,EAAE,UAAU,SAAS,UAAU;AAAA,IAC3E,OAAO;AACH,WAAK,gBAAgB,cAAc,KAAK,EAAE,SAAS,OAAO,EAAE,UAAU,SAAS,SAAA,EAAS,CAAG;AAAA,IAC/F;AAAA,EACJ;AACJ;;"}